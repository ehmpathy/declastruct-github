# blueprint: declastruct-github provider interface

## üå≥ overview

implement the declastruct provider interface for `declastruct-github` to enable declarative resource management via the declastruct framework

this will allow users to:
- declare desired github resource state via typescript
- generate plans showing required changes
- apply plans to make reality match declarations

## üìê architecture

### core components

```
src/
  domain.operations/
    provider/
      getDeclastructGithubProvider.ts  # main provider factory
  access/
    daos/
      DeclaredGithubRepoDao.ts
      DeclaredGithubBranchDao.ts
      DeclaredGithubRepoConfigDao.ts
      DeclaredGithubBranchProtectionDao.ts
  contract/
    sdks/
      index.ts                         # public exports
```

### provider structure

following the declastruct interface pattern:

```ts
DeclastructProvider<TDeclastructDaos, TContext> {
  name: string;                          // e.g., 'github'
  daos: Record<string, DeclastructDao>;  // resource DAOs
  context: TContext;                     // credentials + config
  hooks: {
    beforeAll: () => Promise<void>;
    afterAll: () => Promise<void>;
  }
}
```

### dao structure

each resource needs a DAO implementing:

```ts
DeclastructDao<TResource, TResourceClass, TContext> {
  get: {
    byUnique: (ref, context) => Promise<TResource | null>;
    byPrimary?: (ref, context) => Promise<TResource | null>;
    byRef: (ref, context) => Promise<TResource | null>;
  };
  set: {
    finsert: (resource, context) => Promise<HasMetadata<TResource>>;
    upsert?: (resource, context) => Promise<HasMetadata<TResource>>;
    delete?: (ref, context) => Promise<void>;
  };
}
```

## üó∫Ô∏è implementation plan

### phase 1: provider factory

**file**: `src/domain.operations/provider/getDeclastructGithubProvider.ts`

**purpose**: create the main provider entry point

**interface**:
```ts
/**
 * .what = the declastruct provider type for github resources
 * .why = provides type safety and reusability for the github provider
 */
export type DeclastructGithubProvider = DeclastructProvider<
  {
    DeclaredGithubRepo: DeclastructDao<DeclaredGithubRepo, typeof DeclaredGithubRepo, ContextGithubApi>;
    DeclaredGithubBranch: DeclastructDao<DeclaredGithubBranch, typeof DeclaredGithubBranch, ContextGithubApi>;
    DeclaredGithubRepoConfig: DeclastructDao<DeclaredGithubRepoConfig, typeof DeclaredGithubRepoConfig, ContextGithubApi>;
    DeclaredGithubBranchProtection: DeclastructDao<DeclaredGithubBranchProtection, typeof DeclaredGithubBranchProtection, ContextGithubApi>;
  },
  ContextGithubApi
>;

/**
 * .what = creates a declastruct provider for github resources
 * .why = enables github resource management via declastruct framework
 */
export const getDeclastructGithubProvider = (
  input: {
    credentials: {
      token: string;
    };
  }
): DeclastructGithubProvider
```

**implementation notes**:
- build context from credentials
- instantiate all DAOs with shared context
- return provider with lifecycle hooks (noop for github)

---

### phase 2: resource DAOs

create DAO wrappers for each resource type that adapt existing operations to the declastruct interface

#### 2.1: DeclaredGithubRepoDao

**file**: `src/access/daos/DeclaredGithubRepoDao.ts`

**purpose**: wrap existing repo operations in declastruct DAO interface

**implementation**:
```ts
import { isRefByUnique } from 'domain-objects';

export const DeclaredGithubRepoDao = DeclastructDao.build<
  DeclaredGithubRepo,
  typeof DeclaredGithubRepo,
  ContextGithubApi
>({
  get: {
    byUnique: async (input, context) => {
      return getRepo({ by: { unique: input } }, context);
    },
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredGithubRepo })(input))
        return getRepo({ by: { unique: input.unique } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  set: {
    finsert: async (input, context) => {
      return setRepo({ finsert: input }, context);
    },
    upsert: async (input, context) => {
      return setRepo({ upsert: input }, context);
    },
  },
});
```

**leverages**:
- existing `getRepo()` operation
- existing `setRepo()` operation (already supports finsert/upsert)

---

#### 2.2: DeclaredGithubBranchDao

**file**: `src/access/daos/DeclaredGithubBranchDao.ts`

**purpose**: wrap branch operations in declastruct DAO interface

**implementation**:
```ts
import { isRefByUnique } from 'domain-objects';

export const DeclaredGithubBranchDao = DeclastructDao.build<
  DeclaredGithubBranch,
  typeof DeclaredGithubBranch,
  ContextGithubApi
>({
  get: {
    byUnique: async (input, context) => {
      return getBranch({ by: { unique: input } }, context);
    },
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredGithubBranch })(input))
        return getBranch({ by: { unique: input.unique } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  set: {
    finsert: async (input, context) => {
      return setBranch({ finsert: input }, context);
    },
  },
});
```

**leverages**:
- existing `getBranch()` operation
- existing `setBranch()` operation (already supports finsert)

**note**: branches are immutable after creation - no upsert needed

---

#### 2.3: DeclaredGithubRepoConfigDao

**file**: `src/access/daos/DeclaredGithubRepoConfigDao.ts`

**purpose**: wrap repo config operations in declastruct DAO interface

**implementation**:
```ts
import { isRefByUnique } from 'domain-objects';

export const DeclaredGithubRepoConfigDao = DeclastructDao.build<
  DeclaredGithubRepoConfig,
  typeof DeclaredGithubRepoConfig,
  ContextGithubApi
>({
  get: {
    byUnique: async (input, context) => {
      return getRepoConfig({ by: { unique: input } }, context);
    },
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredGithubRepoConfig })(input))
        return getRepoConfig({ by: { unique: input.unique } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  set: {
    upsert: async (input, context) => {
      return setRepoConfig({ upsert: input }, context);
    },
  },
});
```

**leverages**:
- existing `getRepoConfig()` operation
- existing `setRepoConfig()` operation

**note**: config is always upserted (no separate create)

---

#### 2.4: DeclaredGithubBranchProtectionDao

**file**: `src/access/daos/DeclaredGithubBranchProtectionDao.ts`

**purpose**: wrap branch protection operations in declastruct DAO interface

**implementation**:
```ts
import { isRefByUnique } from 'domain-objects';

export const DeclaredGithubBranchProtectionDao = DeclastructDao.build<
  DeclaredGithubBranchProtection,
  typeof DeclaredGithubBranchProtection,
  ContextGithubApi
>({
  get: {
    byUnique: async (input, context) => {
      return getBranchProtection({ by: { unique: input } }, context);
    },
    byRef: async (input, context) => {
      if (isRefByUnique({ of: DeclaredGithubBranchProtection })(input))
        return getBranchProtection({ by: { unique: input.unique } }, context);
      UnexpectedCodePathError.throw('unsupported ref type', { input });
    },
  },
  set: {
    upsert: async (input, context) => {
      return setBranchProtection({ upsert: input }, context);
    },
  },
});
```

**leverages**:
- existing `getBranchProtection()` operation
- existing `setBranchProtection()` operation

---

### phase 3: exports

update package exports to expose provider interface

**file**: `src/contract/sdks/index.ts`

**purpose**: public SDK exports for npm package consumers

**exports**:
```ts
// provider
export {
  getDeclastructGithubProvider,
  DeclastructGithubProvider,
} from '../../domain.operations/provider/getDeclastructGithubProvider';

// domain objects
export { DeclaredGithubRepo } from '../../domain.objects/DeclaredGithubRepo';
export { DeclaredGithubBranch } from '../../domain.objects/DeclaredGithubBranch';
export { DeclaredGithubRepoConfig } from '../../domain.objects/DeclaredGithubRepoConfig';
export { DeclaredGithubBranchProtection } from '../../domain.objects/DeclaredGithubBranchProtection';
```

**package.json update**:
```json
{
  "main": "dist/contract/sdks/index.js"
}
```

---

### phase 4: integration tests

**file**: `src/domain.operations/provider/getDeclastructGithubProvider.integration.test.ts`

**purpose**: validate full provider interface works with declastruct

**test scenarios**:
```ts
given('a declastruct github provider', () => {
  const provider = getDeclastructGithubProvider({
    credentials: { token: process.env.GITHUB_TOKEN }
  });

  when('using repo dao', () => {
    then('can finsert a repo', async () => { ... });
    then('can get repo by unique', async () => { ... });
    then('can upsert repo', async () => { ... });
  });

  when('using branch dao', () => {
    then('can finsert a branch', async () => { ... });
    then('can get branch by unique', async () => { ... });
  });

  when('using repo config dao', () => {
    then('can upsert repo config', async () => { ... });
    then('can get repo config by unique', async () => { ... });
  });

  when('using branch protection dao', () => {
    then('can upsert branch protection', async () => { ... });
    then('can get branch protection by unique', async () => { ... });
  });
});
```

---

### phase 5: acceptance tests

**file**: `src/contract/sdks/declastruct.acceptance.test.ts`

**purpose**: validate the full declastruct CLI workflow end-to-end via shell invocation

**test scenarios**:
```ts
import { given, when, then } from 'test-fns';
import { execSync } from 'child_process';
import { writeFileSync, readFileSync, mkdirSync, rmSync } from 'fs';
import { join } from 'path';

given('a declastruct resources file', () => {
  const testDir = join(__dirname, '.temp', 'acceptance');
  const resourcesFile = join(testDir, 'resources.ts');
  const planFile = join(testDir, 'plan.json');

  beforeEach(() => {
    // ensure clean test directory
    rmSync(testDir, { recursive: true, force: true });
    mkdirSync(testDir, { recursive: true });

    // write resources file
    writeFileSync(
      resourcesFile,
      `
import {
  getDeclastructGithubProvider,
  DeclaredGithubRepo,
  DeclaredGithubRepoConfig,
  refByUnique,
} from 'declastruct-github';

export const getProviders = async () => [
  getDeclastructGithubProvider({
    credentials: {
      token: process.env.GITHUB_TOKEN!,
    },
  }),
];

export const getResources = async () => {
  const repo = DeclaredGithubRepo.as({
    owner: 'ehmpathy',
    name: 'declastruct-github-demo',
    description: 'demo repo for declastruct-github',
    homepage: null,
    private: true,
    visibility: 'public',
    archived: false,
  });

  const repoConfig = DeclaredGithubRepoConfig.as({
    repo: refByUnique(repo),
    hasIssues: true,
    hasProjects: false,
    hasWiki: false,
    allowSquashMerge: true,
    allowMergeCommit: false,
    allowRebaseMerge: false,
    deleteBranchOnMerge: true,
  });

  return [repo, repoConfig];
};
      `,
    );
  });

  afterEach(() => {
    // cleanup test directory
    rmSync(testDir, { recursive: true, force: true });
  });

  when('generating a plan via declastruct CLI', () => {
    beforeAll(async () => {
      // execute declastruct plan command
      execSync(
        `npx declastruct plan --wish ${resourcesFile} --into ${planFile}`,
        { cwd: testDir, stdio: 'inherit' },
      );
    })
    then('creates a valid plan file', async () => {
      // verify plan file exists
      const planExists = require('fs').existsSync(planFile);
      expect(planExists).toBe(true);

      // verify plan contains expected structure
      const plan = JSON.parse(readFileSync(planFile, 'utf-8'));
      expect(plan).toHaveProperty('resources');
      expect(plan).toHaveProperty('changes');
      expect(Array.isArray(plan.resources)).toBe(true);
      expect(Array.isArray(plan.changes)).toBe(true);
    });

    then('plan includes repo and config resources', async () => {
      // parse plan
      const plan = JSON.parse(readFileSync(planFile, 'utf-8'));

      // verify resources
      const repoResource = plan.resources.find(
        (r: any) => r.type === 'DeclaredGithubRepo',
      );
      const configResource = plan.resources.find(
        (r: any) => r.type === 'DeclaredGithubRepoConfig',
      );

      expect(repoResource).toBeDefined();
      expect(repoResource.name).toBe('test-declastruct-acceptance');
      expect(configResource).toBeDefined();
    });
  });

  when('applying a plan via declastruct CLI', () => {
    then('executes changes and creates resources', async () => {
      // generate plan
      execSync(
        `npx declastruct plan --wish ${resourcesFile} --output ${planFile}`,
        { cwd: testDir, stdio: 'inherit' },
      );

      // apply plan
      execSync(`npx declastruct apply --plan ${planFile}`, {
        cwd: testDir,
        stdio: 'inherit',
      });

      // verify resources were created (check via GitHub API)
      const { getDeclastructGithubProvider } = require('declastruct-github');
      const provider = getDeclastructGithubProvider({
        credentials: { token: process.env.GITHUB_TOKEN! },
      });

      const repo = await provider.daos.DeclaredGithubRepo.get.byUnique(
        { owner: 'test-owner', name: 'test-declastruct-acceptance' },
        provider.context,
      );

      expect(repo).toBeDefined();
      expect(repo!.name).toBe('test-declastruct-acceptance');
    });

    then('is idempotent - applying same plan twice succeeds', async () => {
      // generate plan
      execSync(
        `npx declastruct plan --wish ${resourcesFile} --output ${planFile}`,
        { cwd: testDir, stdio: 'inherit' },
      );

      // apply plan first time
      execSync(`npx declastruct apply --plan ${planFile}`, {
        cwd: testDir,
        stdio: 'inherit',
      });

      // apply plan second time - should succeed without errors
      execSync(`npx declastruct apply --plan ${planFile}`, {
        cwd: testDir,
        stdio: 'inherit',
      });
    });
  });
});
```

**implementation notes**:
- uses `execSync` to invoke declastruct CLI commands from within jest
- creates temporary test directory with resources file
- validates plan generation produces correct JSON structure
- validates apply operation creates resources via GitHub API
- tests idempotency by applying same plan twice
- cleans up test directory after each test

**test data**:
- uses dedicated test repo name to avoid conflicts
- requires `GITHUB_TOKEN` environment variable
- creates private repo for safety

---

### phase 6: documentation

update readme with declastruct usage examples (already present in readme.md)

ensure examples match actual implementation:
- provider initialization
- resource declaration
- plan generation
- plan application

---

## üîë key decisions

### 1. dao location
place DAOs in `src/access/daos/` following the repo's data access layer pattern

### 2. context reuse
leverage existing `ContextGithubApi` type for all DAOs - no new context needed

### 3. operation reuse
wrap existing `get*` and `set*` operations rather than reimplementing - maintains consistency

### 4. ref support
initially support only `byUnique` references (primary keys not applicable to github resources)

### 5. lifecycle hooks
github provider needs no setup/teardown - use noop hooks

---

## üß™ testing strategy

### unit tests
- test DAO wrapper logic in isolation
- mock existing operations to verify correct delegation

### integration tests
- test full provider interface against real github API
- use test repository for safe CRUD operations
- validate idempotency of all operations

### acceptance tests
- test full CLI workflow via shell invocation from jest
- verify plan generation produces valid JSON
- validate apply creates resources via GitHub API
- confirm idempotency by applying plans multiple times

---

## üì¶ deliverables

1. `getDeclastructGithubProvider` factory function in `src/domain.operations/provider/`
2. four DAO implementations in `src/access/daos/` (repo, branch, repoConfig, branchProtection)
3. public exports via `src/contract/sdks/index.ts`
4. package.json main field updated to `dist/contract/sdks/index.js`
5. integration tests validating provider interface
6. acceptance tests validating CLI workflow via shell invocation
7. updated documentation (readme examples already present)

---

## üéØ success criteria

- provider implements full `DeclastructProvider` interface
- all DAOs implement required `DeclastructDao` methods
- integration tests pass against real github API
- users can use via declastruct CLI as shown in readme
- no breaking changes to existing imperative API

---

## üîç dependencies

### existing code (reuse)
- `getRepo`, `setRepo` operations
- `getBranch`, `setBranch` operations
- `getRepoConfig`, `setRepoConfig` operations
- `getBranchProtection`, `setBranchProtection` operations
- all domain objects already defined
- `ContextGithubApi` context type

### new dependencies
- `declastruct` package (already installed)
- `DeclastructProvider` and `DeclastructDao` types from declastruct

### no changes needed
- existing domain objects remain unchanged
- existing operations remain unchanged
- github API client usage remains unchanged

---

## üöÄ implementation order

1. create DAO wrapper classes (parallel - no dependencies between them)
2. create provider factory (depends on DAOs)
3. update exports (depends on provider)
4. write integration tests (depends on exports)
5. write acceptance tests (depends on integration tests passing)
6. validate against readme examples (final validation)

---

## üåä outcome

users will be able to:

```ts
import { getDeclastructGithubProvider, DeclaredGithubRepo, refByUnique } from 'declastruct-github';

export const getProviders = async () => [
  getDeclastructGithubProvider({
    credentials: { token: process.env.GITHUB_TOKEN }
  })
];

export const getResources = async () => [
  DeclaredGithubRepo.as({
    owner: 'myorg',
    name: 'myrepo',
    private: false,
    // ... other config
  })
];
```

then execute via declastruct CLI:

```sh
npx declastruct plan --wish resources.ts --output plan.json
npx declastruct apply --plan plan.json
```
