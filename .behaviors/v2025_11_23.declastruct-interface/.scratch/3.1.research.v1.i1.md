# declastruct interface requirements research

## overview

based on analysis of the [declastruct repository](https://github.com/ehmpathy/declastruct) and the wish documented in this behavior, this document outlines the complete interface requirements for making `declastruct-github` compatible with the declastruct framework.

---

## core interfaces

### 1. DeclastructProvider<TDeclastructDaos, TContext>

the top-level interface that bundles all resource DAOs and lifecycle hooks for github as an infrastructure provider.

**required shape:**

```typescript
export interface DeclastructProvider<
  TDeclastructDaos extends DeclastructDaosShape<TContext> = DeclastructDaosShape<any>,
  TContext = any,
> {
  /**
   * unique name identifying this provider
   */
  name: string;

  /**
   * map of resource class names to their DAOs
   */
  daos: TDeclastructDaos;

  /**
   * provider-specific context (credentials, region, etc)
   */
  context: TContext;

  /**
   * lifecycle hooks for setup and teardown
   */
  hooks: {
    beforeAll: () => Promise<void>;
    afterAll: () => Promise<void>;
  };
}
```

**for declastruct-github:**
- name: `'github'`
- daos: map containing `DeclaredGithubRepo`, `DeclaredGithubBranch`, `DeclaredGithubRepoConfig`, `DeclaredGithubBranchProtection`
- context: github credentials (token), potentially rate limiting config
- hooks: authentication setup/teardown, connection pooling if needed

---

### 2. DeclastructDao<TResource, TResourceClass, TContext>

the standardized data access interface for each resource type. must be implemented for each github resource.

**required shape:**

```typescript
export interface DeclastructDao<
  TResource extends DomainEntity<any>,
  TResourceClass extends Refable<any, any, any>,
  TContext = never,
> {
  get: {
    /**
     * required - fetch by unique keys (enables idempotency)
     */
    byUnique: (
      input: RefByUnique<TResourceClass>,
      context: TContext,
    ) => Promise<TResource | null>;

    /**
     * optional - fetch by primary keys (if resource supports them)
     */
    byPrimary?: (
      input: RefByPrimary<TResourceClass>,
      context: TContext,
    ) => Promise<TResource | null>;

    /**
     * required - fetch by any supported reference type
     */
    byRef: (
      input: Ref<TResourceClass>,
      context: TContext,
    ) => Promise<TResource | null>;
  };

  set: {
    /**
     * required - find or insert resource (idempotent create)
     */
    finsert: (
      input: TResource,
      context: TContext,
    ) => Promise<HasMetadata<TResource>>;

    /**
     * optional - create or update resource (idempotent upsert)
     */
    upsert?: (
      input: TResource,
      context: TContext,
    ) => Promise<HasMetadata<TResource>>;

    /**
     * optional - delete resource
     */
    delete?: (input: Ref<TResourceClass>, context: TContext) => Promise<void>;
  };
}
```

**key requirements:**
- `get.byUnique` - **required**: enables resource lookup via unique identifiers
- `get.byRef` - **required**: flexible lookup supporting any reference type
- `set.finsert` - **required**: idempotent create operation (find or insert)
- `get.byPrimary` - optional: if resource has primary keys separate from unique keys
- `set.upsert` - optional: idempotent update-or-insert
- `set.delete` - optional: resource removal

**for declastruct-github resources:**
- `DeclaredGithubRepo` - unique by `name`, primary by github id
- `DeclaredGithubBranch` - unique by `repo + name`
- `DeclaredGithubRepoConfig` - unique by `repo` reference
- `DeclaredGithubBranchProtection` - unique by `branch` reference

---

### 3. DeclastructChange<TResource>

represents a planned modification to infrastructure. used by declastruct to compute and display the plan.

**shape:**

```typescript
export enum DeclastructChangeAction {
  KEEP = 'KEEP',        // retain resource unchanged
  CREATE = 'CREATE',    // establish new resource
  UPDATE = 'UPDATE',    // modify existing resource
  DESTROY = 'DESTROY',  // remove existing resource
  REPLACE = 'REPLACE'   // delete then recreate resource
}

export interface DeclastructChange<
  TResource extends DomainEntity<any> = DomainEntity<any>,
> {
  forResource: {
    class: string;  // resource class name
    slug: string;   // scannable identifier
  };

  action: DeclastructChangeAction;

  state: {
    desired: TResource | null;    // target state (null if deleting)
    remote: TResource | null;     // current state (null if absent)
    difference: string | null;    // human-readable diff
  };
}
```

**declastruct handles this automatically** - providers don't create changes directly. declastruct:
1. fetches desired resources via the wish file
2. fetches remote resources via `dao.get.byUnique()`
3. computes differences via `computeChange()`
4. generates plan via `planChanges()`

---

### 4. ContextDeclastruct

standard context for rate limiting and concurrency control.

**shape:**

```typescript
export type ContextDeclastruct = {
  bottleneck: Bottleneck | { onPlan: Bottleneck; onApply: Bottleneck };
};
```

**usage:**
- manages request throttling to avoid hitting github api rate limits
- can use single bottleneck or separate instances for plan vs apply phases
- provider context should extend this if rate limiting is needed

---

## resource requirements

each github resource must be a `DomainEntity` from `domain-objects` with:

1. **unique identification** - how to distinguish resources uniquely
   - for `DeclaredGithubRepo`: `{ name }`
   - for `DeclaredGithubBranch`: `{ repo, name }`
   - for `DeclaredGithubRepoConfig`: `{ repo }`
   - for `DeclaredGithubBranchProtection`: `{ branch }`

2. **domain entity metadata** - standard fields via `domain-objects`:
   - `id` - primary identifier (github's internal id)
   - `uuid` - optional universal identifier
   - `createdAt` / `updatedAt` - lifecycle timestamps

3. **reference support** - via `Refable` pattern:
   - `RefByUnique<T>` - reference by unique keys
   - `RefByPrimary<T>` - reference by primary id
   - `Ref<T>` - union of all reference types

---

## implementation checklist

to make `declastruct-github` compatible with declastruct:

### âœ… already done (per readme.md)
- [x] resource domain objects defined (`DeclaredGithubRepo`, `DeclaredGithubBranch`, etc.)
- [x] imperative get/set operations exist (per readme sections)

### ðŸ”¨ required work
- [ ] implement `DeclastructDao` interface for each resource
  - [ ] `DeclaredGithubRepoDao`
  - [ ] `DeclaredGithubBranchDao`
  - [ ] `DeclaredGithubRepoConfigDao`
  - [ ] `DeclaredGithubBranchProtectionDao`

- [ ] implement `DeclastructProvider` factory
  - [ ] `getDeclastructGithubProvider({ credentials })`
  - [ ] bundle all daos into provider.daos map
  - [ ] implement lifecycle hooks (auth setup, teardown)
  - [ ] add context with github client and credentials

- [ ] ensure resources support required operations
  - [ ] `get.byUnique()` - fetch by unique identifiers
  - [ ] `get.byRef()` - fetch via any reference type
  - [ ] `set.finsert()` - idempotent create (find or insert)
  - [ ] optional: `set.upsert()` for updates
  - [ ] optional: `set.delete()` for removal

- [ ] add declastruct as peer dependency
  - [ ] import core types from `declastruct`
  - [ ] ensure typescript compatibility

---

## workflow integration

once implemented, the declastruct workflow becomes:

### wish âœ¨
```typescript
import { getDeclastructGithubProvider, DeclaredGithubRepo } from 'declastruct-github';

export const getProviders = async () => [
  getDeclastructGithubProvider({
    credentials: { token: process.env.GITHUB_TOKEN }
  })
];

export const getResources = async () => [
  DeclaredGithubRepo.as({ name: 'super-repo' }),
  // ... more resources
];
```

### plan ðŸ”®
```sh
npx declastruct plan --wish provision/github/resources.ts --output provision/github/.temp/plan.json
```

declastruct will:
1. call `getProviders()` and `getResources()`
2. for each desired resource, call `dao.get.byUnique()` to fetch remote state
3. compute changes via diff
4. generate plan with all CREATE/UPDATE/DESTROY actions

### apply ðŸª„
```sh
npx declastruct apply --plan provision/github/.temp/plan.json
```

declastruct will:
1. validate plan hash is still current
2. for each change, call appropriate dao method:
   - CREATE â†’ `dao.set.finsert(desired)`
   - UPDATE â†’ `dao.set.upsert(desired)` if available, else error
   - DESTROY â†’ `dao.set.delete(ref)` if available, else error
3. execute changes in dependency order

---

## key patterns

### idempotency
all operations must be idempotent - retries must be safe:
- `finsert()` - find existing or insert new; never duplicate
- `upsert()` - update if exists, insert if not
- checks before mutations to avoid duplicate side effects

### error handling
- return `null` from get operations when resource not found
- throw errors only for actual failures (auth, network, etc.)
- use helpful-errors for rich context

### references
- support both unique and primary references
- `refByUnique()` for natural keys (e.g., repo name)
- `refByPrimary()` for internal ids (e.g., github repo id)

---

## sources

- [declastruct repository](https://github.com/ehmpathy/declastruct)
- [DeclastructProvider interface](https://github.com/ehmpathy/declastruct/blob/main/src/domain.objects/DeclastructProvider.ts)
- [DeclastructDao interface](https://github.com/ehmpathy/declastruct/blob/main/src/domain.objects/DeclastructDao.ts)
- [DeclastructChange interface](https://github.com/ehmpathy/declastruct/blob/main/src/domain.objects/DeclastructChange.ts)
