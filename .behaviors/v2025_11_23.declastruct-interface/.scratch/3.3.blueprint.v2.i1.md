# blueprint: implement declastruct interface for declastruct-github

## context

this blueprint outlines how to implement the declastruct provider interface for `declastruct-github`, enabling declarative management of github resources via the declastruct framework.

**reference:**
- wish: `.behaviors/v2025_11_23.declastruct-interface/0.wish.md`
- research: `.behaviors/v2025_11_23.declastruct-interface/3.1.research.v1.i1.md`
- readme: `readme.md`

---

## current state analysis

### ‚úÖ what exists

**domain objects** - all resources already defined as `DomainEntity`:
- `DeclaredGithubRepo` (src/domain.objects/DeclaredGithubRepo.ts)
  - unique: `['owner', 'name']`
  - has id, createdAt, updatedAt metadata
- `DeclaredGithubBranch` (src/domain.objects/DeclaredGithubBranch.ts)
  - unique: `['repo', 'name']`
- `DeclaredGithubRepoConfig` (src/domain.objects/DeclaredGithubRepoConfig.ts)
  - unique: `['repo']`
- `DeclaredGithubBranchProtection` (src/domain.objects/DeclaredGithubBranchProtection.ts)
  - unique: `['branch']`

**domain operations** - get/set operations already implemented:
- `getRepo()` / `setRepo()` (src/domain.operations/repo/)
- `getBranch()` / `setBranch()` (src/domain.operations/branch/)
- `getRepoConfig()` / `setRepoConfig()` (src/domain.operations/repoConfig/)
- `getBranchProtection()` / `setBranchProtection()` (src/domain.operations/branchProtection/)

**context** - github api context already defined:
- `ContextGithubApi` (src/domain.objects/ContextGithubApi.ts)

**patterns observed:**
- uses `asProcedure()` from `as-procedure` for all operations
- uses `PickOne<{ unique: ..., primary: ... }>` pattern for flexible input
- operations already implement finsert/upsert semantics in `setRepo()` and similar
- returns `null` for 404/not found cases
- uses `HelpfulError` for error wrapping
- uses `VisualogicContext` for logging

---

## üéØ implementation plan

### phase 1: create dao adapters

**goal:** wrap existing get/set operations into declastruct dao interface

**approach:** create thin adapter layer that maps declastruct dao interface to existing operations

#### 1.1 create dao for DeclaredGithubRepo

**file:** `src/contract/daos/DeclaredGithubRepoDao.ts`

```typescript
import { asProcedure } from 'as-procedure';
import {
  DeclastructDao,
  Ref,
  RefByPrimary,
  RefByUnique,
  HasMetadata,
} from 'declastruct';
import { VisualogicContext } from 'visualogic';

import { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import { DeclaredGithubRepo } from '../../domain.objects/DeclaredGithubRepo';
import { getRepo } from '../../domain.operations/repo/getRepo';
import { setRepo } from '../../domain.operations/repo/setRepo';

/**
 * .what = declastruct dao adapter for DeclaredGithubRepo
 * .why = provides standardized declastruct interface for github repo operations
 */
export const DeclaredGithubRepoDao: DeclastructDao<
  DeclaredGithubRepo,
  typeof DeclaredGithubRepo,
  ContextGithubApi & VisualogicContext
> = {
  get: {
    // required - fetch by unique keys (owner + name)
    byUnique: asProcedure(
      async (
        input: RefByUnique<typeof DeclaredGithubRepo>,
        context: ContextGithubApi & VisualogicContext,
      ): Promise<HasMetadata<DeclaredGithubRepo> | null> => {
        return getRepo({ by: { unique: input } }, context);
      },
    ),

    // optional - fetch by primary key (github id)
    byPrimary: asProcedure(
      async (
        input: RefByPrimary<typeof DeclaredGithubRepo>,
        context: ContextGithubApi & VisualogicContext,
      ): Promise<HasMetadata<DeclaredGithubRepo> | null> => {
        // note: github api doesn't support fetch by id alone
        // would need owner context - not currently supported
        return null;
      },
    ),

    // required - fetch by any ref type
    byRef: asProcedure(
      async (
        input: Ref<typeof DeclaredGithubRepo>,
        context: ContextGithubApi & VisualogicContext,
      ): Promise<HasMetadata<DeclaredGithubRepo> | null> => {
        // determine which ref type was provided
        if ('owner' in input && 'name' in input) {
          return getRepo({ by: { unique: input } }, context);
        }
        if ('id' in input) {
          // github api doesn't support lookup by id alone
          return null;
        }
        return null;
      },
    ),
  },

  set: {
    // required - find or insert (idempotent create)
    finsert: asProcedure(
      async (
        input: DeclaredGithubRepo,
        context: ContextGithubApi & VisualogicContext,
      ): Promise<HasMetadata<DeclaredGithubRepo>> => {
        return setRepo({ finsert: input }, context);
      },
    ),

    // optional - upsert (update or insert)
    upsert: asProcedure(
      async (
        input: DeclaredGithubRepo,
        context: ContextGithubApi & VisualogicContext,
      ): Promise<HasMetadata<DeclaredGithubRepo>> => {
        return setRepo({ upsert: input }, context);
      },
    ),

    // optional - delete not currently implemented for repos
    // delete: asProcedure(async (input, context) => { ... })
  },
};
```

#### 1.2 create dao for DeclaredGithubBranch

**file:** `src/contract/daos/DeclaredGithubBranchDao.ts`

follow same pattern as repo dao:
- `get.byUnique` ‚Üí calls `getBranch({ by: { unique: input } }, context)`
- `get.byRef` ‚Üí dispatches to appropriate get method based on ref type
- `set.finsert` ‚Üí calls `setBranch({ finsert: input }, context)`
- `set.upsert` ‚Üí calls `setBranch({ upsert: input }, context)` if supported

#### 1.3 create dao for DeclaredGithubRepoConfig

**file:** `src/contract/daos/DeclaredGithubRepoConfigDao.ts`

same pattern:
- `get.byUnique` ‚Üí calls `getRepoConfig({ by: { unique: input } }, context)`
- `set.finsert` ‚Üí calls `setRepoConfig({ finsert: input }, context)`
- `set.upsert` ‚Üí calls `setRepoConfig({ upsert: input }, context)`

#### 1.4 create dao for DeclaredGithubBranchProtection

**file:** `src/contract/daos/DeclaredGithubBranchProtectionDao.ts`

same pattern:
- `get.byUnique` ‚Üí calls `getBranchProtection({ by: { unique: input } }, context)`
- `set.finsert` ‚Üí calls `setBranchProtection({ finsert: input }, context)`
- `set.upsert` ‚Üí calls `setBranchProtection({ upsert: input }, context)`

---

### phase 2: create provider factory

**goal:** bundle all daos into a declastruct provider with context and lifecycle hooks

#### 2.1 define provider context type

**file:** `src/contract/ContextDeclastructGithub.ts`

```typescript
import { ContextDeclastruct } from 'declastruct';
import { VisualogicContext } from 'visualogic';

import { ContextGithubApi } from '../domain.objects/ContextGithubApi';

/**
 * .what = declastruct provider context for github
 * .why = combines github credentials, logging, and rate limiting for declastruct operations
 */
export type ContextDeclastructGithub = ContextGithubApi &
  VisualogicContext &
  ContextDeclastruct;
```

#### 2.2 create provider factory

**file:** `src/contract/getDeclastructGithubProvider.ts`

```typescript
import { asProcedure } from 'as-procedure';
import Bottleneck from 'bottleneck';
import { DeclastructProvider } from 'declastruct';
import { createLog } from 'visualogic';

import { DeclaredGithubBranch } from '../domain.objects/DeclaredGithubBranch';
import { DeclaredGithubBranchProtection } from '../domain.objects/DeclaredGithubBranchProtection';
import { DeclaredGithubRepo } from '../domain.objects/DeclaredGithubRepo';
import { DeclaredGithubRepoConfig } from '../domain.objects/DeclaredGithubRepoConfig';
import { ContextDeclastructGithub } from './ContextDeclastructGithub';
import { DeclaredGithubBranchDao } from './daos/DeclaredGithubBranchDao';
import { DeclaredGithubBranchProtectionDao } from './daos/DeclaredGithubBranchProtectionDao';
import { DeclaredGithubRepoDao } from './daos/DeclaredGithubRepoDao';
import { DeclaredGithubRepoConfigDao } from './daos/DeclaredGithubRepoConfigDao';

/**
 * .what = factory to create declastruct provider for github
 * .why = bundles github resource daos with context and lifecycle hooks for declastruct integration
 */
export const getDeclastructGithubProvider = asProcedure(
  (input: {
    credentials: { token: string };
    rateLimit?: {
      maxConcurrent?: number;
      minTime?: number;
    };
  }): DeclastructProvider<
    {
      DeclaredGithubRepo: typeof DeclaredGithubRepoDao;
      DeclaredGithubBranch: typeof DeclaredGithubBranchDao;
      DeclaredGithubRepoConfig: typeof DeclaredGithubRepoConfigDao;
      DeclaredGithubBranchProtection: typeof DeclaredGithubBranchProtectionDao;
    },
    ContextDeclastructGithub
  > => {
    // create bottleneck for rate limiting github api calls
    const bottleneck = new Bottleneck({
      maxConcurrent: input.rateLimit?.maxConcurrent ?? 10,
      minTime: input.rateLimit?.minTime ?? 100, // 100ms between requests
    });

    // create context with credentials, logging, and rate limiting
    const context: ContextDeclastructGithub = {
      github: {
        token: input.credentials.token,
      },
      log: createLog(),
      bottleneck,
    };

    return {
      name: 'github',

      daos: {
        DeclaredGithubRepo: DeclaredGithubRepoDao,
        DeclaredGithubBranch: DeclaredGithubBranchDao,
        DeclaredGithubRepoConfig: DeclaredGithubRepoConfigDao,
        DeclaredGithubBranchProtection: DeclaredGithubBranchProtectionDao,
      },

      context,

      hooks: {
        // setup hook - validate credentials before operations
        beforeAll: asProcedure(async () => {
          context.log.debug('github provider initialized');
          // could validate token here if needed
        }),

        // teardown hook - cleanup resources
        afterAll: asProcedure(async () => {
          // flush any pending bottleneck operations
          await bottleneck.stop();
          context.log.debug('github provider shutdown complete');
        }),
      },
    };
  },
);
```

---

### phase 3: export public api

**goal:** expose declastruct interfaces in package exports

#### 3.1 create contract barrel export

**file:** `src/contract/index.ts`

```typescript
// provider factory
export * from './getDeclastructGithubProvider';

// context types
export * from './ContextDeclastructGithub';

// daos (optional - users typically don't need these directly)
export * from './daos/DeclaredGithubRepoDao';
export * from './daos/DeclaredGithubBranchDao';
export * from './daos/DeclaredGithubRepoConfigDao';
export * from './daos/DeclaredGithubBranchProtectionDao';
```

#### 3.2 update main index

**file:** `src/index.ts` (create if doesn't exist)

```typescript
// domain objects - declarative resource types
export * from './domain.objects/DeclaredGithubRepo';
export * from './domain.objects/DeclaredGithubBranch';
export * from './domain.objects/DeclaredGithubRepoConfig';
export * from './domain.objects/DeclaredGithubBranchProtection';
export * from './domain.objects/ContextGithubApi';

// declastruct contract - provider and daos
export * from './contract';

// imperative operations (for backwards compatibility)
export * from './domain.operations/repo/getRepo';
export * from './domain.operations/repo/setRepo';
export * from './domain.operations/branch/getBranch';
export * from './domain.operations/branch/setBranch';
export * from './domain.operations/repoConfig/getRepoConfig';
export * from './domain.operations/repoConfig/setRepoConfig';
export * from './domain.operations/branchProtection/getBranchProtection';
export * from './domain.operations/branchProtection/setBranchProtection';
```

---

### phase 4: add missing dependencies

#### 4.1 verify declastruct is installed

declastruct is already in package.json dependencies (1.1.0) ‚úÖ

#### 4.2 add bottleneck for rate limiting

**command:**
```sh
npm install bottleneck
npm install -D @types/bottleneck
```

**rationale:** github api has rate limits; bottleneck prevents exceeding them

---

### phase 5: update documentation

#### 5.1 update readme.md

add declastruct usage examples at the top, showing:
- how to use `getDeclastructGithubProvider()`
- example wish file with `getProviders()` and `getResources()`
- how to run `npx declastruct plan` and `npx declastruct apply`

keep existing imperative usage examples lower in readme for backwards compatibility.

#### 5.2 add migration guide

**file:** `MIGRATION.md` (optional)

document how existing users can adopt declastruct patterns while maintaining backwards compatibility.

---

## üóÇÔ∏è file structure

after implementation, the structure will be:

```
src/
  contract/                               # declastruct interface layer
    daos/
      DeclaredGithubRepoDao.ts           # dao adapter for repos
      DeclaredGithubBranchDao.ts         # dao adapter for branches
      DeclaredGithubRepoConfigDao.ts     # dao adapter for repo config
      DeclaredGithubBranchProtectionDao.ts # dao adapter for branch protection
    getDeclastructGithubProvider.ts      # provider factory
    ContextDeclastructGithub.ts          # provider context type
    index.ts                             # contract exports

  domain.objects/                        # existing domain models
    DeclaredGithubRepo.ts                # ‚úÖ already exists
    DeclaredGithubBranch.ts              # ‚úÖ already exists
    DeclaredGithubRepoConfig.ts          # ‚úÖ already exists
    DeclaredGithubBranchProtection.ts    # ‚úÖ already exists
    ContextGithubApi.ts                  # ‚úÖ already exists

  domain.operations/                     # existing operations
    repo/
      getRepo.ts                         # ‚úÖ already exists
      setRepo.ts                         # ‚úÖ already exists
    branch/
      getBranch.ts                       # ‚úÖ already exists
      setBranch.ts                       # ‚úÖ already exists
    repoConfig/
      getRepoConfig.ts                   # ‚úÖ already exists
      setRepoConfig.ts                   # ‚úÖ already exists
    branchProtection/
      getBranchProtection.ts             # ‚úÖ already exists
      setBranchProtection.ts             # ‚úÖ already exists

  access/                                # existing infrastructure
    sdks/
      getGithubClient.ts                 # ‚úÖ already exists

  index.ts                               # main package export
```

---

## üß™ testing strategy

### unit tests

**for each dao:**
- test `get.byUnique()` calls underlying operation correctly
- test `get.byRef()` dispatches to appropriate method
- test `set.finsert()` delegates to underlying operation
- test `set.upsert()` delegates when available

**for provider factory:**
- test provider returns correct structure
- test context includes credentials and bottleneck
- test `beforeAll()` and `afterAll()` hooks execute

**file locations:**
```
src/contract/daos/DeclaredGithubRepoDao.test.ts
src/contract/daos/DeclaredGithubBranchDao.test.ts
src/contract/daos/DeclaredGithubRepoConfigDao.test.ts
src/contract/daos/DeclaredGithubBranchProtectionDao.test.ts
src/contract/getDeclastructGithubProvider.test.ts
```

### integration tests

**end-to-end declastruct workflow:**
- create wish file with test resources
- call `getDeclastructGithubProvider()` with test credentials
- use declastruct `planChanges()` to generate plan
- use declastruct `applyChanges()` to execute plan
- verify resources created/updated in github

**file location:**
```
src/contract/getDeclastructGithubProvider.integration.test.ts
```

---

## üé® key design decisions

### 1. adapter pattern over rewrite

**decision:** wrap existing operations rather than rewriting them

**rationale:**
- preserves backwards compatibility
- reuses tested logic
- minimizes risk
- existing operations already implement finsert/upsert semantics correctly

### 2. thin dao layer

**decision:** daos are thin adapters that delegate to domain operations

**rationale:**
- separates concerns: domain operations handle business logic, daos handle interface adaptation
- makes daos easy to understand and maintain
- allows domain operations to evolve independently

### 3. context composition

**decision:** compose `ContextDeclastructGithub` from existing context types

**rationale:**
- reuses `ContextGithubApi` for credentials
- reuses `VisualogicContext` for logging
- adds `ContextDeclastruct` for rate limiting
- follows open/closed principle - extends without modifying

### 4. bottleneck for rate limiting

**decision:** use bottleneck library for github api rate limiting

**rationale:**
- github api has rate limits (5000 req/hr authenticated)
- bottleneck provides queue-based throttling
- supports both concurrent and time-based limits
- mature, well-tested library

### 5. optional byPrimary

**decision:** `dao.get.byPrimary()` returns null for most resources

**rationale:**
- github api typically requires owner context, not just id
- unique keys (owner+name) are more natural for github
- primary key lookup not commonly needed
- keeps implementation simple

---

## üìã implementation checklist

### phase 1: dao adapters
- [ ] create `src/contract/daos/` directory
- [ ] implement `DeclaredGithubRepoDao.ts`
- [ ] implement `DeclaredGithubBranchDao.ts`
- [ ] implement `DeclaredGithubRepoConfigDao.ts`
- [ ] implement `DeclaredGithubBranchProtectionDao.ts`
- [ ] write unit tests for each dao

### phase 2: provider factory
- [ ] create `src/contract/ContextDeclastructGithub.ts`
- [ ] implement `src/contract/getDeclastructGithubProvider.ts`
- [ ] write unit tests for provider factory

### phase 3: exports
- [ ] create `src/contract/index.ts` barrel export
- [ ] create or update `src/index.ts` main export
- [ ] verify typescript compilation succeeds

### phase 4: dependencies
- [ ] verify declastruct is in dependencies ‚úÖ
- [ ] add bottleneck: `npm install bottleneck @types/bottleneck`
- [ ] verify all imports resolve

### phase 5: documentation
- [ ] update readme.md with declastruct examples
- [ ] add usage examples for `getDeclastructGithubProvider()`
- [ ] document wish/plan/apply workflow
- [ ] keep existing imperative examples for backwards compat

### phase 6: testing
- [ ] write integration test for full workflow
- [ ] test with real github api (in test org/repo)
- [ ] verify plan generation works correctly
- [ ] verify apply execution creates/updates resources

### phase 7: validation
- [ ] run full test suite: `npm test`
- [ ] verify typescript types: `npm run test:types`
- [ ] verify lint passes: `npm run test:lint`
- [ ] verify format passes: `npm run test:format`
- [ ] build package: `npm run build`

---

## üîÆ future enhancements

### delete operations

currently, delete is not implemented for most resources. consider adding:
- `dao.set.delete()` for repos (requires org admin permissions)
- `dao.set.delete()` for branches
- handle protection rules when deleting protected branches

### batch operations

for efficiency with many resources:
- implement `dao.get.byMany()` to fetch multiple resources in parallel
- use bottleneck to respect rate limits during batch operations

### drift detection

add command to detect drift between declared and actual state:
- compare wish file resources vs remote github state
- report resources that exist remotely but not in wish
- report configuration drift

### github app support

extend authentication to support github apps:
- add app id + private key authentication
- support installation tokens
- handle token refresh

---

## üåä outcome

once complete, users will be able to:

1. **declare** github resources in typescript wish files
2. **plan** changes via `npx declastruct plan`
3. **review** the generated plan to see what will change
4. **apply** changes via `npx declastruct apply`
5. **track** all infrastructure as code in version control

**backwards compatibility:** existing imperative usage (getRepo, setRepo) remains unchanged and fully supported.

**declastruct compatibility:** package will work seamlessly with declastruct cli and framework.
