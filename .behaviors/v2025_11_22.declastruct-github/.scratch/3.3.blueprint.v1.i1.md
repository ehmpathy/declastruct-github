# Blueprint: Implementing declastruct-github

## Overview

Implement declarative control of GitHub constructs following the declastruct pattern, enabling users to manage GitHub repositories, branches, configurations, and branch protections without Terraform state files.

## Architecture Pattern (from existing AWS Lambda implementation)

The current codebase demonstrates the declastruct pattern with AWS Lambda resources. We'll follow the same architecture for GitHub resources:

### 1. Domain Objects (`src/domain.objects/`)

Each GitHub resource will have:
- **Declared* interface** - defines the declarative structure
- **DomainEntity class** - extends the interface with metadata
- **Primary and Unique keys** - for resource identification

Example structure (following `DeclaredAwsLambda.ts:235-237`):
```typescript
export class DeclaredGithubRepo extends DomainEntity<DeclaredGithubRepo> {
  public static primary = ['id'] as const;
  public static unique = ['owner', 'name'] as const;
}
```

### 2. Context Object (`src/domain.objects/`)

Replace `ContextAwsApi` with `ContextGithubApi`:
```typescript
export interface ContextGithubApi {
  github: {
    token: string;
    owner?: string; // org or user
  };
}
```

### 3. Domain Operations (`src/domain.operations/`)

For each resource type, implement the imperative operations pattern:

#### Directory structure:
```
src/domain.operations/
  repo/
    castToDeclaredGithubRepo.ts
    getRepo.ts
    getRepos.ts
    setRepo.ts
    getRepo.integration.test.ts
    getRepos.integration.test.ts
    setRepo.integration.test.ts
    setRepo.test.ts
  branch/
    castToDeclaredGithubBranch.ts
    getBranch.ts
    getBranches.ts
    setBranch.ts
    [tests...]
  repoConfig/
    castToDeclaredGithubRepoConfig.ts
    getRepoConfig.ts
    setRepoConfig.ts
    [tests...]
  branchProtection/
    castToDeclaredGithubBranchProtection.ts
    getBranchProtection.ts
    setBranchProtection.ts
    [tests...]
```

#### Operation patterns:

**get* operation** (see `getLambda.ts:18-64`):
- Accept `by: { primary | unique | ref }` parameter
- Handle ref delegation to primary/unique
- Use GitHub SDK/API client
- Return `HasMetadata<Declared*> | null`
- Wrap errors with `HelpfulError`

**get*s operation** (see `getLambdas.ts:13-37`):
- Accept pagination parameters `{ page?: { range?, limit? } }`
- Return `HasMetadata<Declared*>[]`
- Use list/search API endpoints

**set* operation** (see `setLambda.ts:22-89`):
- Accept `PickOne<{ findsert, upsert }>`
- Check if resource exists via `get*` operation
- Handle findsert (find or insert) - return existing if found
- Handle upsert (update or insert) - update if exists, create otherwise
- Return the resulting `Declared*` object

**castToDeclared* operation** (see `castToDeclaredAwsLambda.ts:24-46`):
- Convert GitHub API response to `DeclaredGithub*` format
- Use `getOrThrow` helper for required fields
- Map API field names to declarative structure names

## Resources to Implement

Based on `readme.md:20-178`, implement these four resource types:

### 1. DeclaredGithubRepo

**Properties:**
- `id?: number` (metadata - GitHub's repo ID)
- `owner: string` (org or user)
- `name: string`
- `description?: string`
- `homepage?: string`
- `private: boolean`
- `visibility?: 'public' | 'private' | 'internal'`

**GitHub API endpoints:**
- GET `/repos/{owner}/{repo}` - get single repo
- GET `/user/repos` or `/orgs/{org}/repos` - list repos
- POST `/user/repos` or `/orgs/{org}/repos` - create repo
- PATCH `/repos/{owner}/{repo}` - update repo

### 2. DeclaredGithubBranch

**Properties:**
- `repo: Ref<typeof DeclaredGithubRepo>`
- `name: string`
- `sha?: string` (metadata - current commit)
- `protected?: boolean` (metadata)

**GitHub API endpoints:**
- GET `/repos/{owner}/{repo}/branches/{branch}` - get branch
- GET `/repos/{owner}/{repo}/branches` - list branches
- POST `/repos/{owner}/{repo}/git/refs` - create branch (requires sha)

**Note:** Branch creation requires a commit SHA to branch from (typically from main/master)

### 3. DeclaredGithubRepoConfig

**Properties:**
- `repo: Ref<typeof DeclaredGithubRepo>`
- `defaultBranch?: Ref<typeof DeclaredGithubBranch>`
- `hasIssues: boolean`
- `hasProjects: boolean`
- `hasWiki: boolean`
- `hasDownloads: boolean`
- `isTemplate: boolean`
- `allowSquashMerge: boolean`
- `allowMergeCommit: boolean`
- `allowRebaseMerge: boolean`
- `deleteBranchOnMerge: boolean`

**GitHub API endpoints:**
- GET `/repos/{owner}/{repo}` - config is part of repo response
- PATCH `/repos/{owner}/{repo}` - update config

**Note:** This is not a separate resource in GitHub API - it's part of the repo. The `get` operation should return the config subset from the repo, and `set` should update only config fields.

### 4. DeclaredGithubBranchProtection

**Properties:**
- `branch: Ref<typeof DeclaredGithubBranch>`
- `enforceAdmins: boolean`
- `allowsDeletions: boolean`
- `allowsForcePushes: boolean`
- `requireLinearHistory: boolean`
- `requiredStatusChecks?: {`
  - `strict: boolean`
  - `contexts: string[]`
- `}`
- `requiredPullRequestReviews?: {`
  - `dismissStaleReviews?: boolean`
  - `requireCodeOwnerReviews?: boolean`
  - `requiredApprovingReviewCount?: number`
- `}`
- `restrictions?: {`
  - `users?: string[]`
  - `teams?: string[]`
  - `apps?: string[]`
- `}`

**GitHub API endpoints:**
- GET `/repos/{owner}/{repo}/branches/{branch}/protection` - get protection
- PUT `/repos/{owner}/{repo}/branches/{branch}/protection` - set protection
- DELETE `/repos/{owner}/{repo}/branches/{branch}/protection` - remove protection

## GitHub SDK/Client

### Option 1: @octokit/rest (recommended)
```typescript
import { Octokit } from '@octokit/rest';

const github = new Octokit({ auth: context.github.token });
```

**Pros:**
- Official GitHub SDK
- Type-safe
- Well-maintained
- Comprehensive API coverage

### Option 2: @octokit/graphql
For more complex queries, could use GraphQL API

### Package dependencies to add:
```json
{
  "dependencies": {
    "@octokit/rest": "^20.0.0"
  }
}
```

## Test Assets (`src/__test_assets__/`)

Following the pattern from AWS Lambda:

**getSampleGithubContext.ts:**
```typescript
export const getSampleGithubContext = (): ContextGithubApi => ({
  github: {
    token: process.env.GITHUB_TOKEN ?? '',
    owner: process.env.GITHUB_TEST_OWNER ?? 'ehmpathy',
  }
});
```

**getSampleRepo.ts:**
```typescript
export const getSampleRepo = () => ({
  owner: process.env.GITHUB_TEST_OWNER ?? 'ehmpathy',
  name: process.env.GITHUB_TEST_REPO ?? 'test-repo',
});
```

## Integration Tests

Following pattern from `getLambda.integration.test.ts:10-45`:

- Use `given/then` test structure from `test-fns`
- Use live GitHub resources (with env vars for credentials)
- Test against real GitHub API
- Include console.log for debugging during development

Example structure:
```typescript
describe('getRepo', () => {
  const context = { log: console, ...getSampleGithubContext() };

  given('a live example repo in this account', () => {
    then('we should be able to get its state', async () => {
      const repo = await getRepo({
        by: { unique: { owner: 'ehmpathy', name: 'test-repo' } }
      }, context);

      expect(repo?.name).toBe('test-repo');
      expect(repo?.id).toBeDefined();
    });
  });
});
```

## Implementation Order

1. **Phase 1: Core Infrastructure**
   - Update `package.json` - add @octokit/rest dependency
   - Create `ContextGithubApi.ts`
   - Create test assets (getSampleGithubContext, getSampleRepo)

2. **Phase 2: Repo Resource** (simplest, tests the pattern)
   - `DeclaredGithubRepo.ts`
   - `castToDeclaredGithubRepo.ts`
   - `getRepo.ts` + tests
   - `getRepos.ts` + tests
   - `setRepo.ts` + tests

3. **Phase 3: Branch Resource**
   - `DeclaredGithubBranch.ts`
   - Cast, get, gets, set operations + tests

4. **Phase 4: RepoConfig Resource**
   - `DeclaredGithubRepoConfig.ts`
   - Cast, get, set operations + tests
   - Note: No "gets" needed - config is 1:1 with repo

5. **Phase 5: BranchProtection Resource**
   - `DeclaredGithubBranchProtection.ts`
   - Cast, get, set operations + tests
   - Note: No "gets" needed - protection is 1:1 with branch

6. **Phase 6: Cleanup**
   - Remove all AWS Lambda related files
   - Update package.json description
   - Update README if needed
   - Remove @aws-sdk dependencies

## Reference Patterns from Codebase

### Error Handling
- Use `HelpfulError` for caught errors (see `getLambda.ts:61`)
- Use `UnexpectedCodePathError` for impossible states (see `getLambda.ts:49`)
- Return `null` for not-found cases (see `getLambda.ts:60`)

### Type Safety
- Use `asProcedure` wrapper for operations (see `getLambda.ts:18`)
- Use `PickOne<{}>` for mutually exclusive options (see `setLambda.ts:24`)
- Use `HasMetadata<>` for resources with metadata fields (see `getLambda.ts:28`)
- Use `Ref<typeof Declared*>` for references between resources

### SDK Client Initialization
- Create client within each operation function (see `getLambda.ts:36`)
- Don't cache/reuse clients across operations
- Pass context with credentials to each operation

### Domain Objects
- Use `DomainEntity` base class from `domain-objects` package
- Define `primary` and `unique` static properties for keys
- Mark metadata fields as optional with `?`

### Testing
- Integration tests require live resources
- Use environment variables for test configuration
- Use `test-fns` package for `given/then` structure
- Include descriptive test names that explain the scenario

## Notes

- The AWS Lambda implementation will be removed after GitHub implementation is complete
- Follow the exact same pattern/structure for consistency
- All operations should be async and return Promises
- Use TypeScript strict mode (already configured)
- Follow existing code style (eslint/prettier configured)
