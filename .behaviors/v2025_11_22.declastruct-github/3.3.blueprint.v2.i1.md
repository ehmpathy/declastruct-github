# Blueprint v2: Implementing declastruct-github

## Overview

Implement declarative control of GitHub constructs following the declastruct pattern, enabling users to manage GitHub repositories, branches, repository configurations, and branch protections without Terraform state files.

This blueprint follows the exact architecture patterns established in the current codebase's AWS Lambda implementation.

## Goals

1. **Replace Terraform for GitHub management** with a simpler, stateless declarative approach
2. **Eliminate state files** - resources are queried directly from GitHub
3. **Simplify infrastructure management** - declare what you want, plan the changes, apply them
4. **Follow established patterns** - match the AWS Lambda implementation structure exactly

## Architecture Pattern

Following the established pattern from `src/domain.operations/lambda/*` and `src/domain.objects/DeclaredAwsLambda.ts`.

### 1. Domain Objects (`src/domain.objects/`)

Each GitHub resource will have:
- **DeclaredGithub* interface** - defines the declarative structure
- **DomainEntity class** - extends the interface with `primary` and `unique` keys
- Metadata fields marked with `?` (populated by API responses, optional in declarations)

Pattern from `DeclaredAwsLambda.ts:231-237`:
```typescript
export class DeclaredGithubRepo extends DomainEntity<DeclaredGithubRepo> {
  public static primary = ['id'] as const;
  public static unique = ['owner', 'name'] as const;
}
```

### 2. Context Object (`src/domain.objects/`)

Replace `ContextAwsApi` with `ContextGithubApi`:
```typescript
export interface ContextGithubApi {
  github: {
    token: string;      // GitHub personal access token or GitHub App token
    owner?: string;     // Default org or user (optional, can be specified per-resource)
  };
}
```

### 3. Domain Operations (`src/domain.operations/`)

For each resource type, implement imperative operations following the exact pattern:

**Operation signatures:**

- `get{Resource}()` - accepts `by: { primary | unique | ref }`, returns `HasMetadata<Declared*> | null`
- `get{Resource}s()` - accepts optional pagination `{ page?: { range?, limit? } }`, returns `HasMetadata<Declared*>[]`
- `set{Resource}()` - accepts `PickOne<{ finsert, upsert }>`, returns `HasMetadata<Declared*>`
- `castToDeclared{Resource}()` - converts API response to `Declared*` format

**Implementation patterns from existing code:**

1. Use `asProcedure` wrapper (from `getLambda.ts:18`)
2. Handle ref delegation to primary/unique (from `getLambda.ts:30-33`)
3. Initialize SDK client within each operation (from `getLambda.ts:36`)
4. Use `HelpfulError` for caught errors (from `getLambda.ts:61`)
5. Return `null` for not-found cases (from `getLambda.ts:60`)
6. For `set*`: check existence via `get*`, handle finsert vs upsert (from `setLambda.ts:34-47`)

## Resources to Implement

### 1. DeclaredGithubRepo

Represents a GitHub repository.

**Interface:**
```typescript
export interface DeclaredGithubRepo {
  // Metadata (populated by API)
  id?: number;                    // GitHub's internal repo ID
  createdAt?: UniDateTime;        // When repo was created
  updatedAt?: UniDateTime;        // When repo was last updated

  // Required fields
  owner: string;                  // Organization or user name
  name: string;                   // Repository name

  // Optional fields
  description?: string | null;    // Repository description
  homepage?: string | null;       // Homepage URL
  private: boolean;               // Visibility
  visibility?: 'public' | 'private' | 'internal';
  archived?: boolean;             // Archive status
}

export class DeclaredGithubRepo extends DomainEntity<DeclaredGithubRepo> {
  public static primary = ['id'] as const;
  public static unique = ['owner', 'name'] as const;
}
```

**Operations:**
- `getRepo()` → `GET /repos/{owner}/{repo}`
- `getRepos()` → `GET /user/repos` or `GET /orgs/{org}/repos`
- `setRepo()` → Create: `POST /user/repos` or `POST /orgs/{org}/repos`, Update: `PATCH /repos/{owner}/{repo}`
- `castToDeclaredGithubRepo()` → Transform Octokit response

**Files:**
```
src/domain.operations/repo/
  castToDeclaredGithubRepo.ts
  getRepo.ts
  getRepo.integration.test.ts
  getRepos.ts
  getRepos.integration.test.ts
  setRepo.ts
  setRepo.test.ts
  setRepo.integration.test.ts
```

### 2. DeclaredGithubBranch

Represents a branch in a repository.

**Interface:**
```typescript
export interface DeclaredGithubBranch {
  // Metadata
  sha?: string;                   // Current commit SHA
  protected?: boolean;            // Whether protection is enabled

  // Required fields
  repo: Ref<typeof DeclaredGithubRepo>;
  name: string;                   // Branch name (e.g., 'main', 'develop')

  // For creation only
  fromBranch?: string;            // Branch to create from (default: repo's default branch)
}

export class DeclaredGithubBranch extends DomainEntity<DeclaredGithubBranch> {
  public static primary = ['sha'] as const;
  public static unique = ['repo', 'name'] as const;
}
```

**Operations:**
- `getBranch()` → `GET /repos/{owner}/{repo}/branches/{branch}`
- `getBranches()` → `GET /repos/{owner}/{repo}/branches`
- `setBranch()` → Create: `POST /repos/{owner}/{repo}/git/refs` (requires commit SHA), Rename: `POST /repos/{owner}/{repo}/branches/{branch}/rename`
- `castToDeclaredGithubBranch()` → Transform Octokit response

**Notes:**
- Creating a branch requires a commit SHA to branch from
- Default to the default branch's current SHA if `fromBranch` not specified
- Renaming requires a separate API call

**Files:**
```
src/domain.operations/branch/
  castToDeclaredGithubBranch.ts
  getBranch.ts
  getBranch.integration.test.ts
  getBranches.ts
  getBranches.integration.test.ts
  setBranch.ts
  setBranch.test.ts
  setBranch.integration.test.ts
```

### 3. DeclaredGithubRepoConfig

Represents repository configuration settings.

**Interface:**
```typescript
export interface DeclaredGithubRepoConfig {
  // Identity (this is a 1:1 relationship with repo)
  repo: Ref<typeof DeclaredGithubRepo>;

  // Branch settings
  defaultBranch?: string;         // Name of default branch (not a Ref, just the name)

  // Feature toggles
  hasIssues: boolean;
  hasProjects: boolean;
  hasWiki: boolean;
  hasDownloads: boolean;
  hasDiscussions?: boolean;
  isTemplate: boolean;

  // Merge settings
  allowSquashMerge: boolean;
  allowMergeCommit: boolean;
  allowRebaseMerge: boolean;
  allowAutoMerge?: boolean;
  deleteBranchOnMerge: boolean;

  // Squash merge options
  squashMergeCommitTitle?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
  squashMergeCommitMessage?: 'PR_BODY' | 'COMMIT_MESSAGES' | 'BLANK';

  // Merge commit options
  mergeCommitTitle?: 'PR_TITLE' | 'MERGE_MESSAGE';
  mergeCommitMessage?: 'PR_TITLE' | 'PR_BODY' | 'BLANK';

  // Other settings
  webCommitSignoffRequired?: boolean;
}

export class DeclaredGithubRepoConfig extends DomainEntity<DeclaredGithubRepoConfig> {
  public static primary = ['repo'] as const;
  public static unique = ['repo'] as const;
}
```

**Operations:**
- `getRepoConfig()` → `GET /repos/{owner}/{repo}` (extract config subset)
- `setRepoConfig()` → `PATCH /repos/{owner}/{repo}` (update config fields only)
- `castToDeclaredGithubRepoConfig()` → Transform Octokit response

**Notes:**
- No `getRepoConfigs()` - config is 1:1 with repo
- This isn't a separate GitHub resource - it's a subset of the repo object
- `get` extracts config-related fields from the repo
- `set` updates only the config-related fields

**Files:**
```
src/domain.operations/repoConfig/
  castToDeclaredGithubRepoConfig.ts
  getRepoConfig.ts
  getRepoConfig.integration.test.ts
  setRepoConfig.ts
  setRepoConfig.test.ts
  setRepoConfig.integration.test.ts
```

### 4. DeclaredGithubBranchProtection

Represents branch protection rules.

**Interface:**
```typescript
export interface DeclaredGithubBranchProtection {
  // Identity (1:1 relationship with branch)
  branch: Ref<typeof DeclaredGithubBranch>;

  // Admin enforcement
  enforceAdmins: boolean;         // Apply rules to administrators

  // Branch restrictions
  allowsDeletions: boolean;       // Allow branch deletion
  allowsForcePushes: boolean;     // Allow force pushes
  requireLinearHistory: boolean;  // Require linear history (no merge commits)
  blockCreations?: boolean;       // Block branch creation matching this pattern
  lockBranch?: boolean;           // Lock branch (read-only)
  allowForkSyncing?: boolean;     // Allow fork syncing

  // Required status checks
  requiredStatusChecks?: {
    strict: boolean;              // Branch must be up to date before merging
    contexts: string[];           // Required status check context names
  } | null;

  // Pull request reviews
  requiredPullRequestReviews?: {
    dismissStaleReviews?: boolean;
    requireCodeOwnerReviews?: boolean;
    requiredApprovingReviewCount?: number;
    dismissalRestrictions?: {
      users?: string[];
      teams?: string[];
      apps?: string[];
    };
  } | null;

  // Push restrictions
  restrictions?: {
    users?: string[];
    teams?: string[];
    apps?: string[];
  } | null;

  // Signature requirements
  requiredSignatures?: boolean;

  // Conversation resolution
  requiredConversationResolution?: boolean;
}

export class DeclaredGithubBranchProtection extends DomainEntity<DeclaredGithubBranchProtection> {
  public static primary = ['branch'] as const;
  public static unique = ['branch'] as const;
}
```

**Operations:**
- `getBranchProtection()` → `GET /repos/{owner}/{repo}/branches/{branch}/protection`
- `setBranchProtection()` → `PUT /repos/{owner}/{repo}/branches/{branch}/protection` or `DELETE` if all protection removed
- `castToDeclaredGithubBranchProtection()` → Transform Octokit response

**Notes:**
- No `getBranchProtections()` - protection is 1:1 with branch
- API requires entire protection object in PUT request
- Setting `null` for sections removes that protection type
- Returns 404 if no protection exists - map to `null` response

**Files:**
```
src/domain.operations/branchProtection/
  castToDeclaredGithubBranchProtection.ts
  getBranchProtection.ts
  getBranchProtection.integration.test.ts
  setBranchProtection.ts
  setBranchProtection.test.ts
  setBranchProtection.integration.test.ts
```

## GitHub SDK Client

**Package:** `@octokit/rest` (official GitHub SDK)

**Installation:**
```json
{
  "dependencies": {
    "@octokit/rest": "^21.0.0"
  }
}
```

**Initialization pattern (within each operation):**
```typescript
import { Octokit } from '@octokit/rest';

// Inside operation function
const github = new Octokit({ auth: context.github.token });
```

**Why Octokit:**
- Official GitHub SDK with full TypeScript support
- Comprehensive REST API coverage
- Built-in retry logic and rate limiting
- Well-maintained and documented
- Type-safe API methods

## Test Assets (`src/__test_assets__/`)

Following the pattern from AWS Lambda implementation:

**getSampleGithubContext.ts:**
```typescript
import { ContextGithubApi } from '../domain.objects/ContextGithubApi';

export const getSampleGithubContext = (): ContextGithubApi => ({
  github: {
    token: process.env.GITHUB_TOKEN ?? '',
    owner: process.env.GITHUB_TEST_OWNER ?? 'ehmpathy',
  },
});
```

**getSampleRepo.ts:**
```typescript
import { DeclaredGithubRepo } from '../domain.objects/DeclaredGithubRepo';

export const getSampleRepo = (): Pick<DeclaredGithubRepo, 'owner' | 'name'> => ({
  owner: process.env.GITHUB_TEST_OWNER ?? 'ehmpathy',
  name: process.env.GITHUB_TEST_REPO ?? 'declastruct-github',
});
```

## Integration Testing Strategy

Following the pattern from `getLambda.integration.test.ts`:

- Use `given/then` test structure from `test-fns`
- Test against live GitHub API (with env vars for credentials)
- Use real GitHub resources for testing
- Include console logging for debugging
- Test both success and error cases

**Environment variables required for tests:**
```
GITHUB_TOKEN=ghp_...           # GitHub personal access token
GITHUB_TEST_OWNER=ehmpathy     # Owner/org for test repos
GITHUB_TEST_REPO=test-repo     # Test repository name
```

**Example test structure:**
```typescript
import { given, then } from 'test-fns';
import { getSampleGithubContext } from '../../__test_assets__/getSampleGithubContext';
import { getSampleRepo } from '../../__test_assets__/getSampleRepo';
import { getRepo } from './getRepo';

describe('getRepo', () => {
  const context = { log: console, ...getSampleGithubContext() };

  given('a live example repo exists', () => {
    then('we should be able to get its state', async () => {
      const repo = await getRepo({
        by: { unique: getSampleRepo() },
      }, context);

      expect(repo).toBeDefined();
      expect(repo?.name).toBe(getSampleRepo().name);
      expect(repo?.id).toBeDefined();
    });
  });

  given('a repo that does not exist', () => {
    then('it should return null', async () => {
      const repo = await getRepo({
        by: { unique: { owner: 'ehmpathy', name: 'repo-that-does-not-exist-99999' } },
      }, context);

      expect(repo).toBeNull();
    });
  });
});
```

## Implementation Phases

### Phase 1: Core Infrastructure
**Goal:** Set up GitHub SDK and context

**Tasks:**
1. Update `package.json` - add `@octokit/rest` dependency
2. Create `src/domain.objects/ContextGithubApi.ts`
3. Create `src/__test_assets__/getSampleGithubContext.ts`
4. Create `src/__test_assets__/getSampleRepo.ts`

**Deliverable:** Context and test utilities ready for use

### Phase 2: Repository Resource
**Goal:** Implement the simplest resource to validate the pattern

**Tasks:**
1. Create `src/domain.objects/DeclaredGithubRepo.ts`
2. Implement `src/domain.operations/repo/castToDeclaredGithubRepo.ts`
3. Implement `src/domain.operations/repo/getRepo.ts` + integration test
4. Implement `src/domain.operations/repo/getRepos.ts` + integration test
5. Implement `src/domain.operations/repo/setRepo.ts` + unit + integration tests

**Deliverable:** Fully working repo resource with all operations

### Phase 3: Branch Resource
**Goal:** Implement branch management with references to repos

**Tasks:**
1. Create `src/domain.objects/DeclaredGithubBranch.ts`
2. Implement cast function
3. Implement `getBranch.ts` + integration test
4. Implement `getBranches.ts` + integration test
5. Implement `setBranch.ts` + unit + integration tests

**Deliverable:** Fully working branch resource

### Phase 4: Repository Configuration Resource
**Goal:** Implement repo config management (subset of repo)

**Tasks:**
1. Create `src/domain.objects/DeclaredGithubRepoConfig.ts`
2. Implement cast function
3. Implement `getRepoConfig.ts` + integration test
4. Implement `setRepoConfig.ts` + unit + integration tests

**Deliverable:** Fully working repo config resource

### Phase 5: Branch Protection Resource
**Goal:** Implement branch protection rules

**Tasks:**
1. Create `src/domain.objects/DeclaredGithubBranchProtection.ts`
2. Implement cast function
3. Implement `getBranchProtection.ts` + integration test
4. Implement `setBranchProtection.ts` + unit + integration tests

**Deliverable:** Fully working branch protection resource

### Phase 6: Cleanup and Documentation
**Goal:** Remove AWS Lambda code, update documentation

**Tasks:**
1. Remove all AWS Lambda related files:
   - `src/domain.objects/DeclaredAwsLambda.ts`
   - `src/domain.objects/ContextAwsApi.ts`
   - `src/domain.operations/lambda/` (entire directory)
   - `src/__test_assets__/getSampleAwsApiContext.ts`
   - `src/__test_assets__/getSampleLambda.ts`
   - `src/__test_assets__/lambda.sample.*`
2. Remove AWS SDK dependency from `package.json`
3. Update `package.json` description field
4. Verify all tests pass
5. Update `README.md` if needed (already looks good)

**Deliverable:** Clean codebase with only GitHub resources

## Key Implementation Details

### Error Handling Patterns

From `getLambda.ts:55-62`:
```typescript
try {
  const response = await github.repos.get({ owner, repo });
  return castToDeclaredGithubRepo(response.data);
} catch (error) {
  if (!(error instanceof Error)) throw error;
  if (error.message.includes('Not Found')) return null;
  throw new HelpfulError('github.getRepo error', { cause: error });
}
```

### Reference Resolution Pattern

From `getLambda.ts:30-33`:
```typescript
// handle by ref
if (input.by.ref)
  return isRefByUnique({ of: DeclaredGithubRepo })(input.by.ref)
    ? getRepo({ by: { unique: input.by.ref } }, context)
    : getRepo({ by: { primary: input.by.ref } }, context);
```

### Finsert vs Upsert Pattern

From `setLambda.ts:34-47`:
```typescript
// check whether it already exists
const before = await getRepo({
  by: { unique: { owner: desired.owner, name: desired.name } }
}, context);

// if it's a finsert and had a before, then return that
if (before && input.finsert) return before;

// ... handle create or update logic
```

### Cast Function Pattern

Extract and transform API response fields:
```typescript
import { getOrThrow } from 'helpful-errors';

export const castToDeclaredGithubRepo = (
  from: components['schemas']['repository'],
): HasMetadata<DeclaredGithubRepo> => ({
  id: getOrThrow(from.id, 'id'),
  owner: getOrThrow(from.owner?.login, 'owner.login'),
  name: getOrThrow(from.name, 'name'),
  description: from.description ?? null,
  homepage: from.homepage ?? null,
  private: getOrThrow(from.private, 'private'),
  visibility: from.visibility as 'public' | 'private' | 'internal' | undefined,
  archived: from.archived,
  createdAt: from.created_at,
  updatedAt: from.updated_at,
});
```

## API Authentication & Permissions

**Required GitHub Token Permissions:**

For fine-grained personal access tokens:

| Resource | Operation | Permission Required |
|----------|-----------|---------------------|
| Repository | Read | "Metadata" (read) |
| Repository | Create/Update/Delete | "Administration" (write) |
| Branch | List/Get | "Contents" (read) |
| Branch | Create/Rename | "Contents" (write) |
| Branch Protection | Read | "Administration" (read) |
| Branch Protection | Update/Delete | "Administration" (write) |

**For testing:**
- Create a fine-grained personal access token with "Administration" and "Contents" write access to test repositories
- Store in `GITHUB_TOKEN` environment variable

## Dependencies to Add

```json
{
  "dependencies": {
    "@octokit/rest": "^21.0.0"
  }
}
```

## Dependencies to Remove (in Phase 6)

```json
{
  "dependencies": {
    "@aws-sdk/client-lambda": "3.835.0"
  }
}
```

## Testing Configuration

**Required environment variables:**
```bash
# GitHub API credentials
GITHUB_TOKEN=ghp_xxxxxxxxxxxxx

# Test repository details
GITHUB_TEST_OWNER=ehmpathy
GITHUB_TEST_REPO=declastruct-github
```

**Integration test command:**
```bash
npm run test:integration
```

## Success Criteria

1. ✅ All four resource types fully implemented with operations
2. ✅ All operations follow existing patterns exactly
3. ✅ Integration tests pass against live GitHub API
4. ✅ Unit tests cover edge cases
5. ✅ AWS Lambda code completely removed
6. ✅ All existing tests still pass
7. ✅ TypeScript compilation succeeds with no errors
8. ✅ README.md examples work as documented

## Example Usage (from README.md)

After implementation, users will be able to:

```typescript
import { DeclaredGithubRepo, DeclaredGithubRepoConfig } from 'declastruct-github';
import { refByUnique } from 'domain-objects';

export const getResources = async () => {
  const repo = DeclaredGithubRepo.as({
    owner: 'ehmpathy',
    name: 'super-repo',
    private: false,
  });

  const repoConfig = DeclaredGithubRepoConfig.as({
    repo: refByUnique(repo),

    hasIssues: true,
    hasProjects: false,
    hasWiki: false,
    hasDownloads: false,
    isTemplate: false,

    allowSquashMerge: true,
    allowMergeCommit: false,
    allowRebaseMerge: false,

    deleteBranchOnMerge: true,
  });

  return [repo, repoConfig];
}
```

## Notes

- Follow the existing patterns exactly - don't deviate
- Use `asProcedure` for all operations
- Use `VisualogicContext` for logging
- Return `null` for not-found, throw for errors
- Keep SDK client initialization inside each operation
- Mark metadata fields with `?` in interfaces
- Use `HasMetadata<Declared*>` for return types from get operations
- Use `Ref<typeof Declared*>` for relationships between resources
- Test against real GitHub API in integration tests

## Reference Files

Key files to reference for patterns:
- `src/domain.objects/DeclaredAwsLambda.ts` - domain object structure
- `src/domain.operations/lambda/getLambda.ts` - get operation pattern
- `src/domain.operations/lambda/getLambdas.ts` - list operation pattern
- `src/domain.operations/lambda/setLambda.ts` - set operation pattern
- `src/domain.operations/lambda/castToDeclaredAwsLambda.ts` - cast operation pattern
- `src/domain.operations/lambda/getLambda.integration.test.ts` - integration test pattern
- `src/domain.operations/lambda/setLambda.test.ts` - unit test pattern
