# Distilled Domain: GitHub Apps for declastruct-github

## Automation Boundaries

This section clarifies exactly what we automate vs what requires manual user action.

### Legend
- **AUTOMATED** = Fully handled by code via REST API
- **GENERATED** = We generate artifacts (manifest, URLs, forms) for user
- **MANUAL** = User must perform action in browser

### GitHub App Operations

| Operation      | What We Automate                                      | What User Does Manually                                   |
| -------------- | ----------------------------------------------------- | --------------------------------------------------------- |
| **Create App** | GENERATED: manifest JSON, HTML form, registration URL | MANUAL: Submit form in browser, click "Create GitHub App" |
| **Read App**   | AUTOMATED: `GET /app`, `GET /apps/{slug}`             | None                                                      |
| **Update App** | GENERATED: Settings URL, diff of changes              | MANUAL: All changes via GitHub UI                         |
| **Delete App** | GENERATED: Deletion URL                               | MANUAL: Delete via GitHub UI                              |

### GitHub App Installation Operations

| Operation                       | What We Automate                              | What User Does Manually            |
| ------------------------------- | --------------------------------------------- | ---------------------------------- |
| **Create Installation**         | GENERATED: Installation URL                   | MANUAL: Click "Install" in browser |
| **Read Installation**           | AUTOMATED: `GET /app/installations/*`         | None                               |
| **Update Installation (repos)** | AUTOMATED: `PUT/DELETE .../repositories/{id}` | None (for repo add/remove)         |
| **Update Installation (perms)** | GENERATED: Settings URL                       | MANUAL: Permission changes via UI  |
| **Delete Installation**         | AUTOMATED: `DELETE /app/installations/{id}`   | None                               |

### Access Token Operations

| Operation        | What We Automate                        | What User Does Manually |
| ---------------- | --------------------------------------- | ----------------------- |
| **Create Token** | AUTOMATED: `POST .../access_tokens`     | None                    |
| **Revoke Token** | AUTOMATED: `DELETE /installation/token` | None                    |

---

## Use Cases

Based on the wish:
> "wish we could provision github apps so that we can subsequently use their tokens via this project"

### UC1: Provision a GitHub App
**Actor:** Developer/Admin
**Flow:**
1. Developer defines app manifest with permissions, events, webhook config
2. Developer registers app via GitHub UI or manifest flow (manual step)
3. Developer stores `APP_ID` in vars and `PRIVATE_KEY` in secrets
4. System can now reference this app

**Note:** App creation is a one-time manual UI step. The declastruct pattern here is about declaring the desired app configuration and managing installations.

### UC2: Retrieve GitHub App Installation
**Actor:** CI/CD Workflow, Automation Script
**Flow:**
1. System retrieves installation for a specific org or repo
2. System gets installation ID for token generation

### UC3: Generate Installation Access Token
**Actor:** CI/CD Workflow (via `actions/create-github-app-token`)
**Flow:**
1. Workflow uses app credentials (APP_ID, PRIVATE_KEY)
2. Action generates JWT, finds installation, creates access token
3. Token is available for subsequent steps (1 hour validity)

### UC4: Declaratively Manage App Installation Settings
**Actor:** Developer/Admin
**Flow:**
1. Developer declares desired installation configuration (repo selection, permissions)
2. System computes diff between desired and current state
3. System applies changes (add/remove repos from installation)

---

## Envisioned Contract

```typescript
// Example usage in declastruct resources file
import {
  DeclaredGithubApp,
  DeclaredGithubAppInstallation,
  getDeclastructGithubProvider,
} from 'declastruct-github';

export const getProviders = async () => [
  getDeclastructGithubProvider(
    {
      credentials: {
        // For app-level operations, use app authentication
        appId: Number(process.env.GITHUB_APP_ID),
        privateKey: process.env.GITHUB_APP_PRIVATE_KEY,
      },
    },
    { log },
  ),
];

export const getResources = async () => {
  // Declare the app configuration (for documentation/validation)
  const app = DeclaredGithubApp.as({
    slug: 'declastruct-github',
    owner: 'ehmpathy',
    permissions: {
      contents: 'write',
      pullRequests: 'write',
      metadata: 'read',
    },
    events: ['push', 'pull_request'],
  });

  // Declare installation on org
  const installation = DeclaredGithubAppInstallation.as({
    app,
    targetType: 'Organization',
    targetLogin: 'ehmpathy',
    repositorySelection: 'selected',
    repositories: ['declastruct-github', 'declastruct-github-demo'],
  });

  return [app, installation];
};
```

### Token Usage in Workflows

```yaml
# .github/workflows/example.yml
jobs:
  provision:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/create-github-app-token@v2
        id: app-token
        with:
          app-id: ${{ vars.DECLASTRUCT_GITHUB_APP_ID }}
          private-key: ${{ secrets.DECLASTRUCT_GITHUB_APP_PRIVATE_KEY }}
          owner: ehmpathy
          repositories: declastruct-github,declastruct-github-demo

      - uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token }}

      - run: npx declastruct apply --plan plan.json
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
```

---

## Domain Objects

### DeclaredGithubApp

```typescript
import { DomainEntity, DomainLiteral } from 'domain-objects';

/**
 * .what = a declarative structure which represents a GitHub App registration
 * .why = enables declarative documentation and validation of GitHub App configs
 * .note = app creation is manual; this represents desired state for validation
 */
export interface DeclaredGithubApp {
  /**
   * .what = GitHub's internal app ID
   * .note = is @metadata -> may be undefined until app is created
   */
  id?: number;

  /**
   * .what = when the app was created
   * .note = is @metadata -> may be undefined
   */
  createdAt?: UniDateTime;

  /**
   * .what = when the app was last updated
   * .note = is @metadata -> may be undefined
   */
  updatedAt?: UniDateTime;

  /**
   * .what = URL-friendly name of the app
   * .note = e.g., 'declastruct-github', 'please-release'
   */
  slug: string;

  /**
   * .what = organization or user that owns the app
   */
  owner: string;

  /**
   * .what = display name of the app
   * .note = optional; defaults to slug
   */
  name?: string;

  /**
   * .what = description of the app
   */
  description?: string;

  /**
   * .what = whether the app is publicly installable
   * .note = false for internal org apps
   */
  public?: boolean;

  /**
   * .what = permissions the app requests
   */
  permissions: DeclaredGithubAppPermissions;

  /**
   * .what = webhook events the app subscribes to
   */
  events?: string[];

  /**
   * .what = homepage URL for the app
   */
  homepageUrl?: string;

  /**
   * .what = webhook configuration
   */
  webhookUrl?: string;
}

export class DeclaredGithubApp
  extends DomainEntity<DeclaredGithubApp>
  implements DeclaredGithubApp
{
  public static unique = ['owner', 'slug'] as const;
  public static nested = {
    permissions: DomainLiteral,
  };
}
```

### DeclaredGithubAppPermissions (Literal)

```typescript
import { DomainLiteral } from 'domain-objects';

/**
 * .what = permissions configuration for a GitHub App
 * .why = type-safe representation of GitHub App permission settings
 */
export interface DeclaredGithubAppPermissions {
  // Repository permissions
  actions?: 'read' | 'write';
  administration?: 'read' | 'write';
  checks?: 'read' | 'write';
  contents?: 'read' | 'write';
  deployments?: 'read' | 'write';
  environments?: 'read' | 'write';
  issues?: 'read' | 'write';
  metadata?: 'read' | 'write';
  packages?: 'read' | 'write';
  pages?: 'read' | 'write';
  pullRequests?: 'read' | 'write';
  repositoryHooks?: 'read' | 'write';
  repositoryProjects?: 'read' | 'write' | 'admin';
  secretScanningAlerts?: 'read' | 'write';
  secrets?: 'read' | 'write';
  securityEvents?: 'read' | 'write';
  singleFile?: 'read' | 'write';
  statuses?: 'read' | 'write';
  vulnerabilityAlerts?: 'read' | 'write';
  workflows?: 'write';

  // Organization permissions
  members?: 'read' | 'write';
  organizationAdministration?: 'read' | 'write';
  organizationCustomRoles?: 'read' | 'write';
  organizationHooks?: 'read' | 'write';
  organizationPlan?: 'read';
  organizationProjects?: 'read' | 'write' | 'admin';
  organizationSecrets?: 'read' | 'write';
  organizationSelfHostedRunners?: 'read' | 'write';
  organizationUserBlocking?: 'read' | 'write';
  teamDiscussions?: 'read' | 'write';
}

export class DeclaredGithubAppPermissions
  extends DomainLiteral<DeclaredGithubAppPermissions>
  implements DeclaredGithubAppPermissions {}
```

### DeclaredGithubAppInstallation

```typescript
import { DomainEntity, RefByUnique } from 'domain-objects';

import type { DeclaredGithubApp } from './DeclaredGithubApp';

/**
 * .what = a declarative structure representing a GitHub App installation
 * .why = enables declarative management of where a GitHub App is installed
 */
export interface DeclaredGithubAppInstallation {
  /**
   * .what = GitHub's internal installation ID
   * .note = is @metadata -> may be undefined
   */
  id?: number;

  /**
   * .what = when the installation was created
   * .note = is @metadata -> may be undefined
   */
  createdAt?: UniDateTime;

  /**
   * .what = when the installation was last updated
   * .note = is @metadata -> may be undefined
   */
  updatedAt?: UniDateTime;

  /**
   * .what = reference to the GitHub App this installation belongs to
   */
  app: RefByUnique<typeof DeclaredGithubApp>;

  /**
   * .what = type of account where app is installed
   */
  targetType: 'Organization' | 'User';

  /**
   * .what = login/username of the installation target
   * .note = e.g., 'ehmpathy' for org, 'username' for user
   */
  targetLogin: string;

  /**
   * .what = repository access mode
   * .note = 'all' for all repos, 'selected' for specific repos
   */
  repositorySelection?: 'all' | 'selected';

  /**
   * .what = list of repository names when repositorySelection is 'selected'
   * .note = only repo names, not full owner/repo format
   */
  repositories?: string[];

  /**
   * .what = whether the installation is suspended
   * .note = is @metadata -> may be undefined
   */
  suspended?: boolean;
}

export class DeclaredGithubAppInstallation
  extends DomainEntity<DeclaredGithubAppInstallation>
  implements DeclaredGithubAppInstallation
{
  public static unique = ['app', 'targetType', 'targetLogin'] as const;
  public static nested = {
    app: RefByUnique<typeof DeclaredGithubApp>,
  };
}
```

---

## Domain Operations

### App Operations

#### getApp

```typescript
import { asProcedure } from 'as-procedure';
import type { RefByUnique } from 'domain-objects';
import { HelpfulError, UnexpectedCodePathError } from 'helpful-errors';
import type { HasMetadata, PickOne } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import { getGithubAppClient } from '../../access/sdks/getGithubAppClient';
import type { ContextGithubAppApi } from '../../domain.objects/ContextGithubAppApi';
import type { DeclaredGithubApp } from '../../domain.objects/DeclaredGithubApp';
import { castToDeclaredGithubApp } from './castToDeclaredGithubApp';

/**
 * .what = gets a GitHub App by slug
 * .why = retrieves current state of an app from GitHub API
 */
export const getApp = asProcedure(
  async (
    input: {
      by: PickOne<{
        unique: RefByUnique<typeof DeclaredGithubApp>;
        self: true; // get the authenticated app
      }>;
    },
    context: ContextGithubAppApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubApp> | null> => {
    const github = getGithubAppClient({}, context);

    if (input.by.self) {
      try {
        const response = await github.apps.getAuthenticated();
        return castToDeclaredGithubApp(response.data);
      } catch (error) {
        if (!(error instanceof Error)) throw error;
        if (error.message.includes('Not Found')) return null;
        throw new HelpfulError('github.getApp.self error', { cause: error });
      }
    }

    if (input.by.unique) {
      try {
        const response = await github.apps.getBySlug({
          app_slug: input.by.unique.slug,
        });
        return castToDeclaredGithubApp(response.data);
      } catch (error) {
        if (!(error instanceof Error)) throw error;
        if (error.message.includes('Not Found')) return null;
        throw new HelpfulError('github.getApp.bySlug error', { cause: error });
      }
    }

    UnexpectedCodePathError.throw('invalid input', { input });
  },
);
```

#### setApp

```typescript
import { asProcedure } from 'as-procedure';
import { HelpfulError } from 'helpful-errors';
import type { HasMetadata, PickOne } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import type { ContextGithubAppApi } from '../../domain.objects/ContextGithubAppApi';
import type { DeclaredGithubApp } from '../../domain.objects/DeclaredGithubApp';
import { getApp } from './getApp';

/**
 * .what = sets a GitHub App: automates manifest flow then prompts for manual confirmation
 * .why = enables declarative app creation with maximum automation
 */
export const setApp = asProcedure(
  async (
    input: PickOne<{
      findsert: DeclaredGithubApp;
      upsert: DeclaredGithubApp;
    }>,
    context: ContextGithubAppApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubApp>> => {
    const desired = input.findsert ?? input.upsert;

    // Check if app already exists
    const foundBefore = await getApp(
      { by: { unique: { owner: desired.owner, slug: desired.slug } } },
      context,
    );

    // If findsert and found, return foundBefore
    if (foundBefore && input.findsert) return foundBefore;

    // If found, app updates are limited - throw helpful error
    if (foundBefore && input.upsert) {
      throw new HelpfulError(
        'GitHub App updates must be done manually via the GitHub UI. ' +
        'The app already exists but cannot be updated programmatically.',
        {
          foundBefore,
          desiredApp: desired,
          settingsUrl: {
            organization: `https://github.com/organizations/${desired.owner}/settings/apps/${desired.slug}`,
            personal: `https://github.com/settings/apps/${desired.slug}`,
          },
        },
      );
    }

    // Build manifest from declared app config
    const manifest = {
      name: desired.name ?? desired.slug,
      url: desired.homepageUrl ?? `https://github.com/${desired.owner}`,
      hook_attributes: desired.webhookUrl
        ? { url: desired.webhookUrl, active: true }
        : undefined,
      redirect_url: desired.redirectUrl, // Where GitHub sends the code after user confirms
      public: desired.public ?? false,
      default_permissions: desired.permissions,
      default_events: desired.events,
      description: desired.description,
    };

    // NOTE: The POST to github.com/settings/apps/new is a BROWSER FORM SUBMISSION,
    // not a REST API. It returns HTML, not JSON. We cannot automate this step.
    // We must generate the URL/form for the user to submit in their browser.

    // Build registration URL with manifest as form data
    const manifestJson = JSON.stringify(manifest);
    const registrationUrl = {
      organization: `https://github.com/organizations/${desired.owner}/settings/apps/new`,
      personal: `https://github.com/settings/apps/new`,
    };

    // We've done everything we can automatically. Now the user must:
    // 1. POST the manifest via browser form (we provide the form HTML or URL)
    // 2. Click "Create GitHub App" on GitHub's confirmation page
    // 3. GitHub will redirect to redirect_url with a code
    // 4. The code must be exchanged via POST /app-manifests/{code}/conversions
    throw new HelpfulError(
      'GitHub App registration requires manual browser action.\n' +
      'The initial registration is a browser form submission, not a REST API.\n\n' +
      'Please complete these steps:\n' +
      '1. Open the HTML form below in your browser (or use the URL with manifest param)\n' +
      '2. Submit to register, then click "Create GitHub App"\n' +
      '3. After creation, GitHub redirects with a code - exchange it via:\n' +
      '   POST /app-manifests/{code}/conversions\n' +
      '4. Store the returned credentials:\n' +
      '   - APP_ID → repository variable\n' +
      '   - PRIVATE_KEY → repository secret\n' +
      '   - WEBHOOK_SECRET → repository secret (if using webhooks)',
      {
        manifest,
        manifestJson,
        registrationUrl,
        // Provide a ready-to-use HTML form
        htmlForm: `
<form action="${registrationUrl.organization}" method="post">
  <input type="hidden" name="manifest" value='${manifestJson.replace(/'/g, "&#39;")}'>
  <button type="submit">Register GitHub App: ${desired.slug}</button>
</form>`,
        // Or use URL parameters approach (limited, no code exchange)
        urlParamsApproach: buildUrlWithParams(desired),
        desiredApp: desired,
        docsUrl: 'https://docs.github.com/en/apps/sharing-github-apps/registering-a-github-app-from-a-manifest',
      },
    );
  },
);
```

### Installation Operations

#### getAppInstallation

```typescript
import { asProcedure } from 'as-procedure';
import type { RefByUnique } from 'domain-objects';
import { HelpfulError, UnexpectedCodePathError } from 'helpful-errors';
import type { HasMetadata, PickOne } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import { getGithubAppClient } from '../../access/sdks/getGithubAppClient';
import type { ContextGithubAppApi } from '../../domain.objects/ContextGithubAppApi';
import type { DeclaredGithubAppInstallation } from '../../domain.objects/DeclaredGithubAppInstallation';
import { castToDeclaredGithubAppInstallation } from './castToDeclaredGithubAppInstallation';

/**
 * .what = gets a GitHub App installation
 * .why = retrieves installation for an org/user/repo
 */
export const getAppInstallation = asProcedure(
  async (
    input: {
      by: PickOne<{
        unique: RefByUnique<typeof DeclaredGithubAppInstallation>;
        id: number;
        org: string;
        user: string;
        repo: { owner: string; name: string };
      }>;
    },
    context: ContextGithubAppApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubAppInstallation> | null> => {
    const github = getGithubAppClient({}, context);

    try {
      if (input.by.id) {
        const response = await github.apps.getInstallation({
          installation_id: input.by.id,
        });
        return castToDeclaredGithubAppInstallation(response.data, context);
      }

      if (input.by.org) {
        const response = await github.apps.getOrgInstallation({
          org: input.by.org,
        });
        return castToDeclaredGithubAppInstallation(response.data, context);
      }

      if (input.by.user) {
        const response = await github.apps.getUserInstallation({
          username: input.by.user,
        });
        return castToDeclaredGithubAppInstallation(response.data, context);
      }

      if (input.by.repo) {
        const response = await github.apps.getRepoInstallation({
          owner: input.by.repo.owner,
          repo: input.by.repo.name,
        });
        return castToDeclaredGithubAppInstallation(response.data, context);
      }

      if (input.by.unique) {
        const { targetType, targetLogin } = input.by.unique;
        if (targetType === 'Organization') {
          const response = await github.apps.getOrgInstallation({
            org: targetLogin,
          });
          return castToDeclaredGithubAppInstallation(response.data, context);
        }
        if (targetType === 'User') {
          const response = await github.apps.getUserInstallation({
            username: targetLogin,
          });
          return castToDeclaredGithubAppInstallation(response.data, context);
        }
      }

      UnexpectedCodePathError.throw('invalid input', { input });
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      if (error.message.includes('Not Found')) return null;
      throw new HelpfulError('github.getAppInstallation error', { cause: error });
    }
  },
);
```

#### getAppInstallations

```typescript
import { asProcedure } from 'as-procedure';
import { HelpfulError } from 'helpful-errors';
import type { HasMetadata } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import { getGithubAppClient } from '../../access/sdks/getGithubAppClient';
import type { ContextGithubAppApi } from '../../domain.objects/ContextGithubAppApi';
import type { DeclaredGithubAppInstallation } from '../../domain.objects/DeclaredGithubAppInstallation';
import { castToDeclaredGithubAppInstallation } from './castToDeclaredGithubAppInstallation';

/**
 * .what = gets all installations for the authenticated GitHub App
 * .why = lists where the app is installed
 */
export const getAppInstallations = asProcedure(
  async (
    _input: Record<string, never>,
    context: ContextGithubAppApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubAppInstallation>[]> => {
    const github = getGithubAppClient({}, context);

    try {
      const response = await github.apps.listInstallations();
      return Promise.all(
        response.data.map((installation) =>
          castToDeclaredGithubAppInstallation(installation, context),
        ),
      );
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      throw new HelpfulError('github.getAppInstallations error', { cause: error });
    }
  },
);
```

#### setAppInstallation

```typescript
import { asProcedure } from 'as-procedure';
import { HelpfulError } from 'helpful-errors';
import type { HasMetadata, PickOne } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import { getGithubAppClient } from '../../access/sdks/getGithubAppClient';
import type { ContextGithubAppApi } from '../../domain.objects/ContextGithubAppApi';
import type { DeclaredGithubAppInstallation } from '../../domain.objects/DeclaredGithubAppInstallation';
import { getAppInstallation } from './getAppInstallation';

/**
 * .what = sets a GitHub App installation
 * .why = enables declarative management of installations with maximum automation
 *
 * AUTOMATION BOUNDARIES:
 * - AUTOMATED: Reading installation (if found), adding/removing repos
 * - MANUAL: Creating new installation (user must click "Install" in browser)
 */
export const setAppInstallation = asProcedure(
  async (
    input: PickOne<{
      findsert: DeclaredGithubAppInstallation;
      upsert: DeclaredGithubAppInstallation;
    }>,
    context: ContextGithubAppApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubAppInstallation>> => {
    const desired = input.findsert ?? input.upsert;

    // AUTOMATED: Check if installation already exists
    const foundBefore = await getAppInstallation(
      { by: { unique: { app: desired.app, targetType: desired.targetType, targetLogin: desired.targetLogin } } },
      context,
    );

    // If findsert and found, return foundBefore
    if (foundBefore && input.findsert) return foundBefore;

    // If installation doesn't exist, we CANNOT create it via API
    // GENERATED: Provide URL for user to manually install
    if (!foundBefore) {
      throw new HelpfulError(
        'GitHub App installation must be done manually via the GitHub UI.\n' +
        'There is no REST API for creating installations.\n\n' +
        'Please complete these steps:\n' +
        `1. Open: https://github.com/apps/${desired.app.slug}/installations/new\n` +
        `2. Select the "${desired.targetLogin}" ${desired.targetType.toLowerCase()}\n` +
        `3. Choose repository access: ${desired.repositorySelection ?? 'all'}\n` +
        '4. Click "Install" to complete',
        {
          desiredInstallation: desired,
          installationUrl: `https://github.com/apps/${desired.app.slug}/installations/new`,
          targetSelectionUrl: `https://github.com/apps/${desired.app.slug}/installations/select_target`,
          docsUrl: 'https://docs.github.com/en/apps/using-github-apps/installing-a-github-app-from-a-third-party',
        },
      );
    }

    // Installation found - AUTOMATED: Sync repository access if repositorySelection is 'selected'
    if (foundBefore && input.upsert && desired.repositorySelection === 'selected' && desired.repositories) {
      const github = getGithubAppClient({}, context);

      // Get current repos
      const currentReposResponse = await github.apps.listReposAccessibleToInstallation();
      const currentRepoNames = currentReposResponse.data.repositories.map(r => r.name);

      // Calculate diff
      const desiredRepoNames = desired.repositories;
      const toAdd = desiredRepoNames.filter(r => !currentRepoNames.includes(r));
      const toRemove = currentRepoNames.filter(r => !desiredRepoNames.includes(r));

      // AUTOMATED: Add missing repos
      for (const repoName of toAdd) {
        // Need to get repo ID first
        const repoResponse = await github.repos.get({ owner: desired.targetLogin, repo: repoName });
        await github.apps.addRepoToInstallationForAuthenticatedUser({
          installation_id: foundBefore.id!,
          repository_id: repoResponse.data.id,
        });
      }

      // AUTOMATED: Remove extra repos
      for (const repoName of toRemove) {
        const repoResponse = await github.repos.get({ owner: desired.targetLogin, repo: repoName });
        await github.apps.removeRepoFromInstallationForAuthenticatedUser({
          installation_id: foundBefore.id!,
          repository_id: repoResponse.data.id,
        });
      }
    }

    // Return updated installation
    return (await getAppInstallation(
      { by: { id: foundBefore.id! } },
      context,
    ))!;
  },
);
```

#### deleteAppInstallation

```typescript
import { asProcedure } from 'as-procedure';
import { HelpfulError } from 'helpful-errors';
import type { VisualogicContext } from 'visualogic';

import { getGithubAppClient } from '../../access/sdks/getGithubAppClient';
import type { ContextGithubAppApi } from '../../domain.objects/ContextGithubAppApi';
import type { DeclaredGithubAppInstallation } from '../../domain.objects/DeclaredGithubAppInstallation';

/**
 * .what = deletes a GitHub App installation
 * .why = enables programmatic uninstallation
 *
 * AUTOMATION BOUNDARIES:
 * - AUTOMATED: Full deletion via DELETE /app/installations/{id}
 */
export const deleteAppInstallation = asProcedure(
  async (
    input: { installation: DeclaredGithubAppInstallation },
    context: ContextGithubAppApi & VisualogicContext,
  ): Promise<void> => {
    const github = getGithubAppClient({}, context);

    if (!input.installation.id) {
      throw new HelpfulError('Cannot delete installation without ID', {
        installation: input.installation,
      });
    }

    // AUTOMATED: Delete installation via API
    await github.apps.deleteInstallation({
      installation_id: input.installation.id,
    });
  },
);
```

#### createInstallationAccessToken

```typescript
import { asProcedure } from 'as-procedure';
import { HelpfulError } from 'helpful-errors';
import type { VisualogicContext } from 'visualogic';

import { getGithubAppClient } from '../../access/sdks/getGithubAppClient';
import type { ContextGithubAppApi } from '../../domain.objects/ContextGithubAppApi';
import type { DeclaredGithubAppPermissions } from '../../domain.objects/DeclaredGithubAppPermissions';

export interface GithubAppInstallationAccessToken {
  token: string;
  expiresAt: string;
  permissions: DeclaredGithubAppPermissions;
  repositorySelection: 'all' | 'selected';
}

/**
 * .what = creates an installation access token
 * .why = generates short-lived token for API access as the app installation
 *
 * AUTOMATION BOUNDARIES:
 * - AUTOMATED: Full token creation via POST /app/installations/{id}/access_tokens
 */
export const createInstallationAccessToken = asProcedure(
  async (
    input: {
      installationId: number;
      repositories?: string[];
      repositoryIds?: number[];
      permissions?: Partial<DeclaredGithubAppPermissions>;
    },
    context: ContextGithubAppApi & VisualogicContext,
  ): Promise<GithubAppInstallationAccessToken> => {
    const github = getGithubAppClient({}, context);

    try {
      const response = await github.apps.createInstallationAccessToken({
        installation_id: input.installationId,
        repositories: input.repositories,
        repository_ids: input.repositoryIds,
        permissions: input.permissions as Record<string, string>,
      });

      return {
        token: response.data.token,
        expiresAt: response.data.expires_at,
        permissions: response.data.permissions as DeclaredGithubAppPermissions,
        repositorySelection: response.data.repository_selection as 'all' | 'selected',
      };
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      throw new HelpfulError('github.createInstallationAccessToken error', {
        cause: error,
      });
    }
  },
);
```

---

## Access DAOs

### DeclaredGithubAppDao

```typescript
import { DeclastructDao } from 'declastruct';
import { isRefByUnique } from 'domain-objects';
import { UnexpectedCodePathError } from 'helpful-errors';
import type { ContextLogTrail } from 'simple-log-methods';

import type { ContextGithubAppApi } from '../../domain.objects/ContextGithubAppApi';
import { DeclaredGithubApp } from '../../domain.objects/DeclaredGithubApp';
import { getApp } from '../../domain.operations/app/getApp';

/**
 * .what = declastruct DAO for GitHub App resources
 * .why = wraps app operations to conform to declastruct interface
 * .note = apps are created manually via UI; this DAO is read-only with helpful errors
 */
export const DeclaredGithubAppDao = new DeclastructDao<
  typeof DeclaredGithubApp,
  ContextGithubAppApi & ContextLogTrail
>({
  dobj: DeclaredGithubApp,
  get: {
    one: {
      byUnique: async (input, context) => {
        return getApp({ by: { unique: input } }, context);
      },
      byPrimary: null,
      byRef: async (input, context) => {
        if (isRefByUnique({ of: DeclaredGithubApp })(input))
          return getApp({ by: { unique: input } }, context);
        UnexpectedCodePathError.throw('unsupported ref type', { input });
      },
    },
    ref: {
      byPrimary: null,
      byUnique: null,
    },
  },
  set: {
    findsert: async (input, context) => {
      return setApp({ findsert: input }, context);
    },
    upsert: async (input, context) => {
      return setApp({ upsert: input }, context);
    },
    delete: async (input) => {
      throw new HelpfulError(
        'GitHub App deletion must be done manually via the GitHub UI.',
        {
          app: input,
          deletionUrl: {
            organization: `https://github.com/organizations/${input.owner}/settings/apps/${input.slug}`,
            personal: `https://github.com/settings/apps/${input.slug}`,
          },
          docsUrl: 'https://docs.github.com/en/apps/maintaining-github-apps/deleting-a-github-app',
        },
      );
    },
  },
});
```

### DeclaredGithubAppInstallationDao

```typescript
import { DeclastructDao } from 'declastruct';
import { isRefByUnique } from 'domain-objects';
import { UnexpectedCodePathError } from 'helpful-errors';
import type { ContextLogTrail } from 'simple-log-methods';

import type { ContextGithubAppApi } from '../../domain.objects/ContextGithubAppApi';
import { DeclaredGithubAppInstallation } from '../../domain.objects/DeclaredGithubAppInstallation';
import { getAppInstallation } from '../../domain.operations/appInstallation/getAppInstallation';

/**
 * .what = declastruct DAO for GitHub App Installation resources
 * .why = wraps installation operations to conform to declastruct interface
 * .note = installations are created via GitHub UI; this DAO can manage repo access
 */
export const DeclaredGithubAppInstallationDao = new DeclastructDao<
  typeof DeclaredGithubAppInstallation,
  ContextGithubAppApi & ContextLogTrail
>({
  dobj: DeclaredGithubAppInstallation,
  get: {
    one: {
      byUnique: async (input, context) => {
        return getAppInstallation({ by: { unique: input } }, context);
      },
      byPrimary: async (input, context) => {
        if (typeof input === 'number')
          return getAppInstallation({ by: { id: input } }, context);
        UnexpectedCodePathError.throw('unsupported primary key type', { input });
      },
      byRef: async (input, context) => {
        if (isRefByUnique({ of: DeclaredGithubAppInstallation })(input))
          return getAppInstallation({ by: { unique: input } }, context);
        UnexpectedCodePathError.throw('unsupported ref type', { input });
      },
    },
    ref: {
      byPrimary: null,
      byUnique: null,
    },
  },
  set: {
    findsert: async (input, context) => {
      return setAppInstallation({ findsert: input }, context);
    },
    upsert: async (input, context) => {
      return setAppInstallation({ upsert: input }, context);
    },
    delete: async (input, context) => {
      // Deletion IS supported via API
      return deleteAppInstallation({ installation: input }, context);
    },
  },
});
```

---

## Context Types

### ContextGithubAppApi

```typescript
/**
 * .what = context for GitHub App API authentication
 * .why = enables operations that require app-level authentication (JWT)
 */
export interface ContextGithubAppApi {
  githubApp: {
    appId: number;
    privateKey: string;
    installationId?: number; // if operating as a specific installation
  };
}
```

---

## Provider Updates

### Updated DeclastructGithubProvider

```typescript
import type { DeclastructDao, DeclastructProvider } from 'declastruct';
import type { ContextLogTrail } from 'simple-log-methods';

import type { ContextGithubApi } from './ContextGithubApi';
import type { ContextGithubAppApi } from './ContextGithubAppApi';
import type { DeclaredGithubApp } from './DeclaredGithubApp';
import type { DeclaredGithubAppInstallation } from './DeclaredGithubAppInstallation';
import type { DeclaredGithubBranch } from './DeclaredGithubBranch';
import type { DeclaredGithubBranchProtection } from './DeclaredGithubBranchProtection';
import type { DeclaredGithubRepo } from './DeclaredGithubRepo';
import type { DeclaredGithubRepoConfig } from './DeclaredGithubRepoConfig';

/**
 * .what = the declastruct provider for github resources
 * .why = provides type safety and reusability for the github provider
 */
export type DeclastructGithubProvider = DeclastructProvider<
  {
    // Existing resources
    DeclaredGithubRepo: DeclastructDao<
      typeof DeclaredGithubRepo,
      ContextGithubApi & ContextLogTrail
    >;
    DeclaredGithubBranch: DeclastructDao<
      typeof DeclaredGithubBranch,
      ContextGithubApi & ContextLogTrail
    >;
    DeclaredGithubRepoConfig: DeclastructDao<
      typeof DeclaredGithubRepoConfig,
      ContextGithubApi & ContextLogTrail
    >;
    DeclaredGithubBranchProtection: DeclastructDao<
      typeof DeclaredGithubBranchProtection,
      ContextGithubApi & ContextLogTrail
    >;

    // New GitHub App resources
    DeclaredGithubApp: DeclastructDao<
      typeof DeclaredGithubApp,
      ContextGithubAppApi & ContextLogTrail
    >;
    DeclaredGithubAppInstallation: DeclastructDao<
      typeof DeclaredGithubAppInstallation,
      ContextGithubAppApi & ContextLogTrail
    >;
  },
  (ContextGithubApi | ContextGithubAppApi) & ContextLogTrail
>;
```

---

## SDK Client

### getGithubAppClient

```typescript
import { Octokit } from '@octokit/rest';
import { createAppAuth } from '@octokit/auth-app';

import type { ContextGithubAppApi } from '../../domain.objects/ContextGithubAppApi';

let cachedClient: Octokit | null = null;
let cachedContext: ContextGithubAppApi | null = null;

/**
 * .what = gets a cached Octokit client authenticated as a GitHub App
 * .why = reuses client instance for performance, authenticates via JWT
 */
export const getGithubAppClient = (
  _input: Record<string, never>,
  context: ContextGithubAppApi,
): Octokit => {
  // return cached client if context matches
  if (
    cachedClient &&
    cachedContext?.githubApp.appId === context.githubApp.appId &&
    cachedContext?.githubApp.privateKey === context.githubApp.privateKey
  ) {
    return cachedClient;
  }

  // create new authenticated client
  cachedClient = new Octokit({
    authStrategy: createAppAuth,
    auth: {
      appId: context.githubApp.appId,
      privateKey: context.githubApp.privateKey,
      installationId: context.githubApp.installationId,
    },
  });

  cachedContext = context;
  return cachedClient;
};
```

---

## Summary

### New Files Required

**Domain Objects:**
- `src/domain.objects/DeclaredGithubApp.ts`
- `src/domain.objects/DeclaredGithubAppPermissions.ts`
- `src/domain.objects/DeclaredGithubAppInstallation.ts`
- `src/domain.objects/ContextGithubAppApi.ts`

**Domain Operations:**
- `src/domain.operations/app/getApp.ts`
- `src/domain.operations/app/castToDeclaredGithubApp.ts`
- `src/domain.operations/appInstallation/getAppInstallation.ts`
- `src/domain.operations/appInstallation/getAppInstallations.ts`
- `src/domain.operations/appInstallation/castToDeclaredGithubAppInstallation.ts`
- `src/domain.operations/appInstallation/createInstallationAccessToken.ts`

**Access:**
- `src/access/daos/DeclaredGithubAppDao.ts`
- `src/access/daos/DeclaredGithubAppInstallationDao.ts`
- `src/access/sdks/getGithubAppClient.ts`

**Updates:**
- `src/domain.objects/DeclastructGithubProvider.ts` - add new DAOs
- `src/domain.operations/provider/getDeclastructGithubProvider.ts` - wire up new DAOs
- `src/contract/sdks/index.ts` - export new types

### Key Considerations

1. **Two Auth Modes:**
   - Token-based (`ContextGithubApi`) - for operations on repos/branches using PAT or installation token
   - App-based (`ContextGithubAppApi`) - for app-level operations using JWT (appId + privateKey)

2. **Token Generation in Workflows:** Use `actions/create-github-app-token@v2` for CI/CD rather than programmatic token generation.

---

## Automation vs Manual Action Summary

### What We FULLY AUTOMATE (via REST API)

| Operation                      | API Endpoint                                             |
| ------------------------------ | -------------------------------------------------------- |
| Read app info                  | `GET /app`, `GET /apps/{slug}`                           |
| Read installations             | `GET /app/installations`, `GET /orgs/{org}/installation` |
| Add repo to installation       | `PUT /user/installations/{id}/repositories/{repo_id}`    |
| Remove repo from installation  | `DELETE /user/installations/{id}/repositories/{repo_id}` |
| Delete installation            | `DELETE /app/installations/{id}`                         |
| Create access token            | `POST /app/installations/{id}/access_tokens`             |
| Suspend/unsuspend installation | `PUT/DELETE /app/installations/{id}/suspended`           |

### What We GENERATE (for user to complete manually)

| Operation               | What We Generate                            | User Action                                               |
| ----------------------- | ------------------------------------------- | --------------------------------------------------------- |
| **Create App**          | Manifest JSON, HTML form, registration URLs | Submit form, click "Create GitHub App", store credentials |
| **Update App**          | Settings URL, diff of desired vs actual     | Navigate to URL, make changes in UI                       |
| **Delete App**          | Deletion URL                                | Navigate to URL, confirm deletion                         |
| **Create Installation** | Installation URL with app slug              | Navigate to URL, select repos, click "Install"            |

### HelpfulError Pattern

All manual operations throw `HelpfulError` with:
- Clear message explaining why automation isn't possible
- Step-by-step instructions for manual completion
- Pre-generated URLs specific to the resource
- Documentation links
- Context object with all relevant data (manifest, diff, etc.)
