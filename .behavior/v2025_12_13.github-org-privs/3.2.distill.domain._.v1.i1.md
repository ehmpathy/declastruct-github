# Distilled Domain: GitHub Organization Privileges for declastruct-github

## Automation Boundaries

This section clarifies exactly what we automate vs what requires manual user action.

### Legend
- **AUTOMATED** = Fully handled by code via REST API
- **GENERATED** = We generate artifacts (URLs, diff reports) for user
- **MANUAL** = User must perform action in browser

### GitHub Organization Settings Operations

| Operation               | What We Automate               | What User Does Manually |
| ----------------------- | ------------------------------ | ----------------------- |
| **Read Org Settings**   | AUTOMATED: `GET /orgs/{org}`   | None                    |
| **Update Org Settings** | AUTOMATED: `PATCH /orgs/{org}` | None                    |

### GitHub Organization Variable Operations

| Operation           | What We Automate                                         | What User Does Manually |
| ------------------- | -------------------------------------------------------- | ----------------------- |
| **List Variables**  | AUTOMATED: `GET /orgs/{org}/actions/variables`           | None                    |
| **Read Variable**   | AUTOMATED: `GET /orgs/{org}/actions/variables/{name}`    | None                    |
| **Create Variable** | AUTOMATED: `POST /orgs/{org}/actions/variables`          | None                    |
| **Update Variable** | AUTOMATED: `PATCH /orgs/{org}/actions/variables/{name}`  | None                    |
| **Delete Variable** | AUTOMATED: `DELETE /orgs/{org}/actions/variables/{name}` | None                    |

### GitHub Organization Secret Operations

| Operation                | What We Automate                                                    | What User Does Manually   |
| ------------------------ | ------------------------------------------------------------------- | ------------------------- |
| **List Secrets**         | AUTOMATED: `GET /orgs/{org}/actions/secrets` (metadata only)        | None                      |
| **Read Secret**          | AUTOMATED: `GET /orgs/{org}/actions/secrets/{name}` (metadata only) | None                      |
| **Create/Update Secret** | AUTOMATED: `PUT /orgs/{org}/actions/secrets/{name}`                 | Provide value via env var |
| **Delete Secret**        | AUTOMATED: `DELETE /orgs/{org}/actions/secrets/{name}`              | None                      |

---

## Use Cases

Based on the wish:
> "we were able to control github org settings member privileges via declastruct in order to prove and guarantee that 'member privileges' has 'Repository deletion and transfer' disabled for anyone except owners"

### UC1: Enforce Organization Security Settings
**Actor:** DevOps/Admin
**Flow:**
1. Developer declares desired org security settings (e.g., `membersCanDeleteRepositories: false`)
2. System reads current org settings via API
3. System computes diff between desired and current state
4. System applies changes via `PATCH /orgs/{org}`

**Key Settings:**
- `membersCanDeleteRepositories: false` - Prevents non-owners from deleting/transferring repos
- `membersCanChangeRepoVisibility: false` - Prevents non-owners from changing repo visibility

### UC2: Manage Organization Variables
**Actor:** DevOps/Admin
**Flow:**
1. Developer declares organization variables with name, value, visibility
2. System reads current variables via API
3. System computes diff and applies changes (create/update/delete)

### UC3: Manage Organization Secrets (Write-Only)
**Actor:** DevOps/Admin
**Flow:**
1. Developer declares organization secret names with visibility settings
2. System reads current secret metadata (names exist, but values are never readable)
3. If secret value is provided via `process.env.SECRET_VALUE`, system encrypts and writes
4. If secret exists but no value provided, system shows `[KEEP]` to indicate secret exists

**Write-Only Pattern:**
- Secret values are NEVER readable via API
- On read: returns metadata only (name, visibility, created_at)
- On write: requires encryption with org public key before sending

---

## Envisioned Contract

```typescript
// Example usage in declastruct resources file
import {
  DeclaredGithubOrg,
  DeclaredGithubOrgMemberPrivileges,
  DeclaredGithubOrgVariable,
  DeclaredGithubOrgSecret,
  getDeclastructGithubProvider,
} from 'declastruct-github';

export const getProviders = async () => [
  getDeclastructGithubProvider(
    {
      credentials: {
        token: process.env.GITHUB_TOKEN!, // requires admin:org scope
      },
    },
    { log },
  ),
];

export const getResources = async () => {
  // Declare organization profile
  const org = DeclaredGithubOrg.as({
    login: 'ehmpathy',
    name: 'Ehmpathy',
    description: 'Building empathetic software',
    billingEmail: 'billing@ehmpathy.com',
  });

  // Declare organization member privileges (KEY SECURITY SETTINGS)
  const memberPrivileges = DeclaredGithubOrgMemberPrivileges.as({
    org: { login: 'ehmpathy' }, // RefByUnique<DeclaredGithubOrg>
    // Repository creation
    membersCanCreateRepositories: true,
    membersCanCreatePublicRepositories: true,
    membersCanCreatePrivateRepositories: true,
    membersCanCreateInternalRepositories: null, // not enterprise
    // KEY SECURITY SETTINGS - wish fulfillment
    membersCanDeleteRepositories: false,      // only owners can delete/transfer
    membersCanChangeRepoVisibility: false,    // only owners can change visibility
    membersCanForkPrivateRepositories: false,
    // Collaboration
    membersCanInviteOutsideCollaborators: true,
    membersCanCreateTeams: true,
    // GitHub Pages
    membersCanCreatePages: true,
    membersCanCreatePublicPages: true,
    membersCanCreatePrivatePages: true,
    // Other
    membersCanViewDependencyInsights: true,
    defaultRepositoryPermission: 'read',
  });

  // Declare organization variables
  const npmToken = DeclaredGithubOrgVariable.as({
    org: { login: 'ehmpathy' },
    name: 'NPM_TOKEN_READ_ONLY',
    value: process.env.NPM_TOKEN_READ_ONLY!,
    visibility: 'all', // all repos in org
  });

  const awsRegion = DeclaredGithubOrgVariable.as({
    org: { login: 'ehmpathy' },
    name: 'AWS_REGION',
    value: 'us-east-1',
    visibility: 'selected',
    selectedRepositoryNames: ['service-api', 'service-web'],
  });

  // Declare organization secrets (write-only)
  const deployKey = DeclaredGithubOrgSecret.as({
    org: { login: 'ehmpathy' },
    name: 'DEPLOY_KEY',
    // value comes from env var - if not set, existing value is kept
    value: process.env.DEPLOY_KEY,
    visibility: 'private', // only private repos
  });

  const awsAccessKey = DeclaredGithubOrgSecret.as({
    org: { login: 'ehmpathy' },
    name: 'AWS_ACCESS_KEY_ID',
    value: process.env.AWS_ACCESS_KEY_ID,
    visibility: 'selected',
    selectedRepositoryNames: ['service-api'],
  });

  return [org, memberPrivileges, npmToken, awsRegion, deployKey, awsAccessKey];
};
```

---

## Domain Objects

### DeclaredGithubOrg

```typescript
import type { UniDateTime } from '@ehmpathy/uni-time';
import { DomainEntity } from 'domain-objects';

/**
 * .what = a declarative structure which represents GitHub Organization profile
 * .why = enables declarative management of org profile settings
 */
export interface DeclaredGithubOrg {
  /**
   * .what = GitHub's internal org ID
   * .note = is @metadata -> may be undefined
   */
  id?: number;

  /**
   * .what = when the org was created
   * .note = is @metadata -> may be undefined
   */
  createdAt?: UniDateTime;

  /**
   * .what = when the org was last updated
   * .note = is @metadata -> may be undefined
   */
  updatedAt?: UniDateTime;

  /**
   * .what = organization login/handle
   * .note = e.g., 'ehmpathy'
   */
  login: string;

  /**
   * .what = display name of the organization (shown on profile)
   * .note = null if not set (falls back to login in UI)
   */
  name: string | null;

  /**
   * .what = organization description
   * .note = null if not set
   */
  description: string | null;

  /**
   * .what = billing email address
   * .note = null if not set
   */
  billingEmail: string | null;

  // ============================================
  // READ-ONLY METADATA
  // ============================================

  /**
   * .what = whether 2FA is required for all members
   * .note = is @metadata -> read-only
   */
  twoFactorRequirementEnabled?: boolean;

  /**
   * .what = count of public repos
   * .note = is @metadata -> read-only
   */
  publicRepos?: number;
}

export class DeclaredGithubOrg
  extends DomainEntity<DeclaredGithubOrg>
  implements DeclaredGithubOrg
{
  public static primary = ['id'] as const;
  public static unique = ['login'] as const;
  public static readonly = ['twoFactorRequirementEnabled', 'publicRepos'] as const;
}
```

### DeclaredGithubOrgMemberPrivileges

```typescript
import type { UniDateTime } from '@ehmpathy/uni-time';
import { DomainEntity, RefByUnique } from 'domain-objects';

import type { DeclaredGithubOrg } from './DeclaredGithubOrg';

/**
 * .what = a declarative structure which represents GitHub Organization member privileges
 * .why = enables declarative management of what org members are allowed to do
 * .note = KEY SECURITY RESOURCE - controls what non-owners can do
 */
export interface DeclaredGithubOrgMemberPrivileges {
  /**
   * .what = when the settings were last updated
   * .note = is @metadata -> may be undefined
   */
  updatedAt?: UniDateTime;

  /**
   * .what = reference to the organization
   */
  org: RefByUnique<typeof DeclaredGithubOrg>;

  // ============================================
  // REPOSITORY CREATION
  // ============================================

  /**
   * .what = whether non-admin members can create repositories
   */
  membersCanCreateRepositories: boolean;

  /**
   * .what = whether members can create PUBLIC repositories
   * .note = only applies if membersCanCreateRepositories is true
   */
  membersCanCreatePublicRepositories: boolean;

  /**
   * .what = whether members can create PRIVATE repositories
   * .note = only applies if membersCanCreateRepositories is true
   */
  membersCanCreatePrivateRepositories: boolean;

  /**
   * .what = whether members can create INTERNAL repositories
   * .note = only available for enterprise orgs; null if not enterprise
   */
  membersCanCreateInternalRepositories: boolean | null;

  // ============================================
  // REPOSITORY MANAGEMENT (KEY SECURITY SETTINGS)
  // ============================================

  /**
   * .what = whether members with admin permissions can DELETE or TRANSFER repositories
   * .note = KEY SECURITY SETTING - false means only org owners can delete/transfer
   * .note = GitHub default is true (DANGEROUS)
   */
  membersCanDeleteRepositories: boolean;

  /**
   * .what = whether members with admin permissions can change repository VISIBILITY
   * .note = KEY SECURITY SETTING - false means only org owners can change visibility
   * .note = GitHub default is true (DANGEROUS)
   */
  membersCanChangeRepoVisibility: boolean;

  /**
   * .what = whether members can fork private repositories
   */
  membersCanForkPrivateRepositories: boolean;

  // ============================================
  // COLLABORATION
  // ============================================

  /**
   * .what = whether members can invite outside collaborators
   */
  membersCanInviteOutsideCollaborators: boolean;

  /**
   * .what = whether members can create teams
   */
  membersCanCreateTeams: boolean;

  // ============================================
  // GITHUB PAGES
  // ============================================

  /**
   * .what = whether members can create GitHub Pages sites
   */
  membersCanCreatePages: boolean;

  /**
   * .what = whether members can create public GitHub Pages sites
   */
  membersCanCreatePublicPages: boolean;

  /**
   * .what = whether members can create private GitHub Pages sites
   */
  membersCanCreatePrivatePages: boolean;

  // ============================================
  // OTHER
  // ============================================

  /**
   * .what = whether members can view dependency insights
   */
  membersCanViewDependencyInsights: boolean;

  /**
   * .what = default permission level for new repos
   */
  defaultRepositoryPermission: 'read' | 'write' | 'admin' | 'none';
}

export class DeclaredGithubOrgMemberPrivileges
  extends DomainEntity<DeclaredGithubOrgMemberPrivileges>
  implements DeclaredGithubOrgMemberPrivileges
{
  public static unique = ['org'] as const;
  public static readonly = ['updatedAt'] as const;
  public static nested = {
    org: RefByUnique<typeof DeclaredGithubOrg>,
  };
}
```

### DeclaredGithubOrgVariable

```typescript
import type { UniDateTime } from '@ehmpathy/uni-time';
import { DomainEntity, RefByUnique } from 'domain-objects';

import type { DeclaredGithubOrg } from './DeclaredGithubOrg';

/**
 * .what = a declarative structure representing a GitHub Organization variable
 * .why = enables declarative management of org-level GitHub Actions variables
 */
export interface DeclaredGithubOrgVariable {
  /**
   * .what = reference to the organization
   */
  org: RefByUnique<typeof DeclaredGithubOrg>;

  /**
   * .what = variable name
   * .note = must be unique per org
   */
  name: string;

  /**
   * .what = variable value
   * .note = stored in plain text (not encrypted)
   */
  value: string;

  /**
   * .what = visibility scope for the variable
   * .note = 'all' = all repos, 'private' = private repos only, 'selected' = specific repos
   */
  visibility: 'all' | 'private' | 'selected';

  /**
   * .what = repository names when visibility is 'selected'
   * .note = only repo names, not full owner/repo format
   */
  selectedRepositoryNames?: string[];

  /**
   * .what = when the variable was created
   * .note = is @metadata -> may be undefined
   */
  createdAt?: UniDateTime;

  /**
   * .what = when the variable was last updated
   * .note = is @metadata -> may be undefined
   */
  updatedAt?: UniDateTime;
}

export class DeclaredGithubOrgVariable
  extends DomainEntity<DeclaredGithubOrgVariable>
  implements DeclaredGithubOrgVariable
{
  public static unique = ['org', 'name'] as const;
  public static readonly = ['createdAt', 'updatedAt'] as const;
  public static nested = {
    org: RefByUnique<typeof DeclaredGithubOrg>,
  };
}
```

### DeclaredGithubOrgSecret

```typescript
import type { UniDateTime } from '@ehmpathy/uni-time';
import { DomainEntity, RefByUnique } from 'domain-objects';

import type { DeclaredGithubOrg } from './DeclaredGithubOrg';

/**
 * .what = a declarative structure representing a GitHub Organization secret
 * .why = enables declarative management of org-level GitHub Actions secrets
 *
 * WRITE-ONLY PATTERN:
 * - Secret values are NEVER readable via API
 * - On read: only metadata (name, visibility, created_at) is returned
 * - On write: value must be encrypted with org public key before sending
 * - If value is undefined: existing secret is kept unchanged (shows [KEEP])
 * - If value is provided: secret is created/updated with new encrypted value
 */
export interface DeclaredGithubOrgSecret {
  /**
   * .what = reference to the organization
   */
  org: RefByUnique<typeof DeclaredGithubOrg>;

  /**
   * .what = secret name
   * .note = must be unique per org
   */
  name: string;

  /**
   * .what = secret value (write-only)
   * .note = if undefined, existing secret is kept unchanged
   * .note = value is encrypted before being sent to API
   */
  value?: string;

  /**
   * .what = visibility scope for the secret
   * .note = 'all' = all repos, 'private' = private repos only, 'selected' = specific repos
   */
  visibility: 'all' | 'private' | 'selected';

  /**
   * .what = repository names when visibility is 'selected'
   * .note = only repo names, not full owner/repo format
   */
  selectedRepositoryNames?: string[];

  /**
   * .what = when the secret was created
   * .note = is @metadata -> may be undefined
   */
  createdAt?: UniDateTime;

  /**
   * .what = when the secret was last updated
   * .note = is @metadata -> may be undefined
   */
  updatedAt?: UniDateTime;
}

export class DeclaredGithubOrgSecret
  extends DomainEntity<DeclaredGithubOrgSecret>
  implements DeclaredGithubOrgSecret
{
  public static unique = ['org', 'name'] as const;
  public static readonly = ['createdAt', 'updatedAt'] as const;
  public static writeonly = ['value'] as const;
  public static nested = {
    org: RefByUnique<typeof DeclaredGithubOrg>,
  };
}
```

---

## Domain Operations

### Organization Operations

#### getOneOrg

```typescript
import { asProcedure } from 'as-procedure';
import type { RefByUnique } from 'domain-objects';
import { HelpfulError, UnexpectedCodePathError } from 'helpful-errors';
import type { HasMetadata, PickOne } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import { getGithubClient } from '../../access/sdks/getGithubClient';
import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import type { DeclaredGithubOrg } from '../../domain.objects/DeclaredGithubOrg';
import { castToDeclaredGithubOrg } from './castToDeclaredGithubOrg';

/**
 * .what = gets a GitHub Organization's settings
 * .why = retrieves current state of org for declarative management
 */
export const getOneOrg = asProcedure(
  async (
    input: {
      by: PickOne<{
        unique: RefByUnique<typeof DeclaredGithubOrg>;
      }>;
    },
    context: ContextGithubApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubOrg> | null> => {
    const github = getGithubClient({}, context);

    const login = (() => {
      if (input.by.unique) return input.by.unique.login;
      UnexpectedCodePathError.throw('not referenced by unique', { input });
    })();

    try {
      const response = await github.orgs.get({ org: login });
      return castToDeclaredGithubOrg(response.data);
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      if (error.message.includes('Not Found')) return null;
      throw new HelpfulError('github.getOrg error', { cause: error });
    }
  },
);
```

#### setOrg

```typescript
import { asProcedure } from 'as-procedure';
import { HelpfulError } from 'helpful-errors';
import type { HasMetadata, PickOne } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import { getGithubClient } from '../../access/sdks/getGithubClient';
import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import type { DeclaredGithubOrg } from '../../domain.objects/DeclaredGithubOrg';
import { castToDeclaredGithubOrg } from './castToDeclaredGithubOrg';
import { getOneOrg } from './getOneOrg';

/**
 * .what = sets GitHub Organization profile settings
 * .why = enables declarative management of org profile
 *
 * AUTOMATION BOUNDARIES:
 * - AUTOMATED: Profile settings via PATCH /orgs/{org}
 * - NOTE: Cannot create organizations via API (only update existing)
 * - NOTE: Member privileges are managed via DeclaredGithubOrgMemberPrivileges
 */
export const setOrg = asProcedure(
  async (
    input: PickOne<{
      findsert: DeclaredGithubOrg;
      upsert: DeclaredGithubOrg;
    }>,
    context: ContextGithubApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubOrg>> => {
    const desired = input.findsert ?? input.upsert;
    const github = getGithubClient({}, context);

    // Check if org exists
    const before = await getOneOrg(
      { by: { unique: { login: desired.login } } },
      context,
    );

    // Cannot create orgs via API - must exist
    if (!before) {
      throw new HelpfulError(
        'GitHub Organization does not exist and cannot be created via API.\n' +
        'Organizations must be created manually via the GitHub UI.',
        {
          createUrl: 'https://github.com/organizations/plan',
          desiredOrg: desired,
        },
      );
    }

    // If findsert and found, return as-is (no changes)
    if (before && input.findsert) return before;

    // Apply profile updates via PATCH
    try {
      const response = await github.orgs.update({
        org: desired.login,
        name: desired.name ?? undefined,
        description: desired.description ?? undefined,
        billing_email: desired.billingEmail ?? undefined,
      });

      return castToDeclaredGithubOrg(response.data);
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      throw new HelpfulError('github.setOrg.update error', { cause: error });
    }
  },
);
```

### Organization Member Privileges Operations

#### getOneOrgMemberPrivileges

```typescript
import { asProcedure } from 'as-procedure';
import type { RefByUnique } from 'domain-objects';
import { HelpfulError, UnexpectedCodePathError } from 'helpful-errors';
import type { HasMetadata, PickOne } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import { getGithubClient } from '../../access/sdks/getGithubClient';
import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import type { DeclaredGithubOrgMemberPrivileges } from '../../domain.objects/DeclaredGithubOrgMemberPrivileges';
import { castToDeclaredGithubOrgMemberPrivileges } from './castToDeclaredGithubOrgMemberPrivileges';

/**
 * .what = gets GitHub Organization member privileges
 * .why = retrieves current security settings for declarative management
 */
export const getOneOrgMemberPrivileges = asProcedure(
  async (
    input: {
      by: PickOne<{
        unique: RefByUnique<typeof DeclaredGithubOrgMemberPrivileges>;
      }>;
    },
    context: ContextGithubApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubOrgMemberPrivileges> | null> => {
    const github = getGithubClient({}, context);

    const org = (() => {
      if (input.by.unique) return input.by.unique.org;
      UnexpectedCodePathError.throw('not referenced by unique', { input });
    })();

    try {
      const response = await github.orgs.get({ org: org.login });
      return castToDeclaredGithubOrgMemberPrivileges({ data: response.data, org });
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      if (error.message.includes('Not Found')) return null;
      throw new HelpfulError('github.getOrgMemberPrivileges error', { cause: error });
    }
  },
);
```

#### setOrgMemberPrivileges

```typescript
import { asProcedure } from 'as-procedure';
import { HelpfulError } from 'helpful-errors';
import type { HasMetadata, PickOne } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import { getGithubClient } from '../../access/sdks/getGithubClient';
import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import type { DeclaredGithubOrgMemberPrivileges } from '../../domain.objects/DeclaredGithubOrgMemberPrivileges';
import { castToDeclaredGithubOrgMemberPrivileges } from './castToDeclaredGithubOrgMemberPrivileges';
import { getOneOrgMemberPrivileges } from './getOneOrgMemberPrivileges';

/**
 * .what = sets GitHub Organization member privileges
 * .why = enables declarative management of org security settings
 *
 * KEY SECURITY SETTINGS:
 * - membersCanDeleteRepositories: false -> only owners can delete/transfer repos
 * - membersCanChangeRepoVisibility: false -> only owners can change visibility
 */
export const setOrgMemberPrivileges = asProcedure(
  async (
    input: PickOne<{
      findsert: DeclaredGithubOrgMemberPrivileges;
      upsert: DeclaredGithubOrgMemberPrivileges;
    }>,
    context: ContextGithubApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubOrgMemberPrivileges>> => {
    const desired = input.findsert ?? input.upsert;
    const github = getGithubClient({}, context);

    // Check current state
    const before = await getOneOrgMemberPrivileges(
      { by: { unique: { org: desired.org } } },
      context,
    );

    // Org must exist
    if (!before) {
      throw new HelpfulError(
        'GitHub Organization does not exist.',
        { desiredPrivileges: desired },
      );
    }

    // If findsert and found, return as-is (no changes)
    if (before && input.findsert) return before;

    // Apply member privilege updates via PATCH
    try {
      const response = await github.orgs.update({
        org: desired.org.login,
        // Repository creation
        members_can_create_repositories: desired.membersCanCreateRepositories,
        members_can_create_public_repositories: desired.membersCanCreatePublicRepositories,
        members_can_create_private_repositories: desired.membersCanCreatePrivateRepositories,
        members_can_create_internal_repositories: desired.membersCanCreateInternalRepositories ?? undefined,
        // KEY SECURITY SETTINGS
        members_can_delete_repositories: desired.membersCanDeleteRepositories,
        members_can_change_repo_visibility: desired.membersCanChangeRepoVisibility,
        members_can_fork_private_repositories: desired.membersCanForkPrivateRepositories,
        // Collaboration
        // Note: members_can_invite_outside_collaborators not directly settable via API
        // Note: members_can_create_teams not directly settable via API
        // GitHub Pages
        members_can_create_pages: desired.membersCanCreatePages,
        members_can_create_public_pages: desired.membersCanCreatePublicPages,
        members_can_create_private_pages: desired.membersCanCreatePrivatePages,
        // Other
        default_repository_permission: desired.defaultRepositoryPermission,
      });

      return castToDeclaredGithubOrgMemberPrivileges({ data: response.data, org: desired.org });
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      throw new HelpfulError('github.setOrgMemberPrivileges.update error', { cause: error });
    }
  },
);
```

### Organization Variable Operations

#### getOneOrgVariable

```typescript
import { asProcedure } from 'as-procedure';
import type { RefByUnique } from 'domain-objects';
import { HelpfulError, UnexpectedCodePathError } from 'helpful-errors';
import type { HasMetadata, PickOne } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import { getGithubClient } from '../../access/sdks/getGithubClient';
import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import type { DeclaredGithubOrgVariable } from '../../domain.objects/DeclaredGithubOrgVariable';
import { castToDeclaredGithubOrgVariable } from './castToDeclaredGithubOrgVariable';

/**
 * .what = gets a GitHub Organization variable
 * .why = retrieves current state for declarative management
 */
export const getOneOrgVariable = asProcedure(
  async (
    input: {
      by: PickOne<{
        unique: RefByUnique<typeof DeclaredGithubOrgVariable>;
      }>;
    },
    context: ContextGithubApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubOrgVariable> | null> => {
    const github = getGithubClient({}, context);

    const { org, name } = (() => {
      if (input.by.unique) return { org: input.by.unique.org, name: input.by.unique.name };
      UnexpectedCodePathError.throw('not referenced by unique', { input });
    })();

    try {
      const response = await github.actions.getOrgVariable({ org: org.login, name });
      return castToDeclaredGithubOrgVariable({ data: response.data, org });
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      if (error.message.includes('Not Found')) return null;
      throw new HelpfulError('github.getOrgVariable error', { cause: error });
    }
  },
);
```

#### getAllOrgVariables

```typescript
import { asProcedure } from 'as-procedure';
import type { RefByUnique } from 'domain-objects';
import { HelpfulError } from 'helpful-errors';
import type { HasMetadata } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import { getGithubClient } from '../../access/sdks/getGithubClient';
import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import type { DeclaredGithubOrg } from '../../domain.objects/DeclaredGithubOrg';
import type { DeclaredGithubOrgVariable } from '../../domain.objects/DeclaredGithubOrgVariable';
import { castToDeclaredGithubOrgVariable } from './castToDeclaredGithubOrgVariable';

/**
 * .what = gets all GitHub Organization variables
 * .why = retrieves current state for declarative management
 */
export const getAllOrgVariables = asProcedure(
  async (
    input: { org: RefByUnique<typeof DeclaredGithubOrg> },
    context: ContextGithubApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubOrgVariable>[]> => {
    const github = getGithubClient({}, context);

    try {
      const response = await github.actions.listOrgVariables({ org: input.org.login });
      return response.data.variables.map((v) =>
        castToDeclaredGithubOrgVariable({ data: v, org: input.org }),
      );
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      throw new HelpfulError('github.getAllOrgVariables error', { cause: error });
    }
  },
);
```

#### setOrgVariable

```typescript
import { asProcedure } from 'as-procedure';
import { HelpfulError } from 'helpful-errors';
import type { HasMetadata, PickOne } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import { getGithubClient } from '../../access/sdks/getGithubClient';
import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import type { DeclaredGithubOrgVariable } from '../../domain.objects/DeclaredGithubOrgVariable';
import { castToDeclaredGithubOrgVariable } from './castToDeclaredGithubOrgVariable';
import { getOneOrgVariable } from './getOneOrgVariable';
import { getRepoIdsByNames } from '../repo/getRepoIdsByNames';

/**
 * .what = sets a GitHub Organization variable
 * .why = enables declarative management of org-level variables
 */
export const setOrgVariable = asProcedure(
  async (
    input: PickOne<{
      findsert: DeclaredGithubOrgVariable;
      upsert: DeclaredGithubOrgVariable;
    }>,
    context: ContextGithubApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubOrgVariable>> => {
    const desired = input.findsert ?? input.upsert;
    const github = getGithubClient({}, context);

    // Check if variable exists
    const before = await getOneOrgVariable(
      { by: { unique: { org: desired.org, name: desired.name } } },
      context,
    );

    // Resolve repo IDs if visibility is 'selected'
    const selectedRepositoryIds = desired.visibility === 'selected' && desired.selectedRepositoryNames
      ? await getRepoIdsByNames({ org: desired.org.login, names: desired.selectedRepositoryNames }, context)
      : undefined;

    // If findsert and found, return as-is
    if (before && input.findsert) return before;

    // If exists, update
    if (before && input.upsert) {
      try {
        await github.actions.updateOrgVariable({
          org: desired.org.login,
          name: desired.name,
          value: desired.value,
          visibility: desired.visibility,
          selected_repository_ids: selectedRepositoryIds,
        });

        return (await getOneOrgVariable(
          { by: { unique: { org: desired.org, name: desired.name } } },
          context,
        ))!;
      } catch (error) {
        if (!(error instanceof Error)) throw error;
        throw new HelpfulError('github.setOrgVariable.update error', { cause: error });
      }
    }

    // Create new variable
    try {
      await github.actions.createOrgVariable({
        org: desired.org.login,
        name: desired.name,
        value: desired.value,
        visibility: desired.visibility,
        selected_repository_ids: selectedRepositoryIds,
      });

      return (await getOneOrgVariable(
        { by: { unique: { org: desired.org, name: desired.name } } },
        context,
      ))!;
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      throw new HelpfulError('github.setOrgVariable.create error', { cause: error });
    }
  },
);
```

#### delOrgVariable

```typescript
import { asProcedure } from 'as-procedure';
import { HelpfulError } from 'helpful-errors';
import type { VisualogicContext } from 'visualogic';

import { getGithubClient } from '../../access/sdks/getGithubClient';
import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import type { DeclaredGithubOrgVariable } from '../../domain.objects/DeclaredGithubOrgVariable';

/**
 * .what = deletes a GitHub Organization variable
 * .why = enables declarative management of org-level variables
 */
export const delOrgVariable = asProcedure(
  async (
    input: { variable: DeclaredGithubOrgVariable },
    context: ContextGithubApi & VisualogicContext,
  ): Promise<void> => {
    const github = getGithubClient({}, context);

    try {
      await github.actions.delOrgVariable({
        org: input.variable.org.login,
        name: input.variable.name,
      });
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      throw new HelpfulError('github.delOrgVariable error', { cause: error });
    }
  },
);
```

### Organization Secret Operations

#### getOneOrgSecret

```typescript
import { asProcedure } from 'as-procedure';
import type { RefByUnique } from 'domain-objects';
import { HelpfulError, UnexpectedCodePathError } from 'helpful-errors';
import type { HasMetadata, PickOne } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import { getGithubClient } from '../../access/sdks/getGithubClient';
import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import type { DeclaredGithubOrgSecret } from '../../domain.objects/DeclaredGithubOrgSecret';
import { castToDeclaredGithubOrgSecret } from './castToDeclaredGithubOrgSecret';

/**
 * .what = gets a GitHub Organization secret (metadata only)
 * .why = retrieves current state for declarative management
 * .note = value is NEVER returned - secrets are write-only
 */
export const getOneOrgSecret = asProcedure(
  async (
    input: {
      by: PickOne<{
        unique: RefByUnique<typeof DeclaredGithubOrgSecret>;
      }>;
    },
    context: ContextGithubApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubOrgSecret> | null> => {
    const github = getGithubClient({}, context);

    const { org, name } = (() => {
      if (input.by.unique) return { org: input.by.unique.org, name: input.by.unique.name };
      UnexpectedCodePathError.throw('not referenced by unique', { input });
    })();

    try {
      const response = await github.actions.getOrgSecret({ org: org.login, secret_name: name });
      return castToDeclaredGithubOrgSecret({ data: response.data, org });
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      if (error.message.includes('Not Found')) return null;
      throw new HelpfulError('github.getOrgSecret error', { cause: error });
    }
  },
);
```

#### getAllOrgSecrets

```typescript
import { asProcedure } from 'as-procedure';
import type { RefByUnique } from 'domain-objects';
import { HelpfulError } from 'helpful-errors';
import type { HasMetadata } from 'type-fns';
import type { VisualogicContext } from 'visualogic';

import { getGithubClient } from '../../access/sdks/getGithubClient';
import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import type { DeclaredGithubOrg } from '../../domain.objects/DeclaredGithubOrg';
import type { DeclaredGithubOrgSecret } from '../../domain.objects/DeclaredGithubOrgSecret';
import { castToDeclaredGithubOrgSecret } from './castToDeclaredGithubOrgSecret';

/**
 * .what = gets all GitHub Organization secrets (metadata only)
 * .why = retrieves current state for declarative management
 * .note = values are NEVER returned - secrets are write-only
 */
export const getAllOrgSecrets = asProcedure(
  async (
    input: { org: RefByUnique<typeof DeclaredGithubOrg> },
    context: ContextGithubApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubOrgSecret>[]> => {
    const github = getGithubClient({}, context);

    try {
      const response = await github.actions.listOrgSecrets({ org: input.org.login });
      return response.data.secrets.map((s) =>
        castToDeclaredGithubOrgSecret({ data: s, org: input.org }),
      );
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      throw new HelpfulError('github.getAllOrgSecrets error', { cause: error });
    }
  },
);
```

#### setOrgSecret

```typescript
import { asProcedure } from 'as-procedure';
import { HelpfulError } from 'helpful-errors';
import type { HasMetadata, PickOne } from 'type-fns';
import type { VisualogicContext } from 'visualogic';
import sodium from 'libsodium-wrappers';

import { getGithubClient } from '../../access/sdks/getGithubClient';
import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import type { DeclaredGithubOrgSecret } from '../../domain.objects/DeclaredGithubOrgSecret';
import { getOneOrgSecret } from './getOneOrgSecret';
import { getRepoIdsByNames } from '../repo/getRepoIdsByNames';

/**
 * .what = encrypts a secret value using the org's public key
 * .why = GitHub requires secrets to be encrypted before sending
 */
const encryptSecret = async (input: {
  value: string;
  publicKey: string;
}): Promise<string> => {
  await sodium.ready;
  const binKey = sodium.from_base64(input.publicKey, sodium.base64_variants.ORIGINAL);
  const binSec = sodium.from_string(input.value);
  const encBytes = sodium.crypto_box_seal(binSec, binKey);
  return sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL);
};

/**
 * .what = sets a GitHub Organization secret
 * .why = enables declarative management of org-level secrets
 *
 * WRITE-ONLY PATTERN:
 * - If value is undefined and secret exists: keeps existing value (no-op)
 * - If value is undefined and secret doesn't exist: throws error (must provide value)
 * - If value is provided: encrypts and creates/updates secret
 */
export const setOrgSecret = asProcedure(
  async (
    input: PickOne<{
      findsert: DeclaredGithubOrgSecret;
      upsert: DeclaredGithubOrgSecret;
    }>,
    context: ContextGithubApi & VisualogicContext,
  ): Promise<HasMetadata<DeclaredGithubOrgSecret>> => {
    const desired = input.findsert ?? input.upsert;
    const github = getGithubClient({}, context);

    // Check if secret exists (metadata only)
    const before = await getOneOrgSecret(
      { by: { unique: { org: desired.org, name: desired.name } } },
      context,
    );

    // If findsert and found, return as-is (no changes needed)
    if (before && input.findsert) return before;

    // If no value provided and secret doesn't exist, error
    if (!desired.value && !before) {
      throw new HelpfulError(
        'Cannot create secret without a value. ' +
        'Provide the secret value via process.env or directly.',
        { desiredSecret: desired },
      );
    }

    // If no value provided and secret exists, check if we can skip the update
    // NOTE: GitHub API requires encrypted_value for PUT, so we cannot update
    // visibility without re-providing the value.
    if (!desired.value && before) {
      const visibilityChanged = desired.visibility !== before.visibility;
      const selectedReposChanged =
        desired.visibility === 'selected' &&
        JSON.stringify(desired.selectedRepositoryNames?.sort()) !==
          JSON.stringify(before.selectedRepositoryNames?.sort());

      if (visibilityChanged || selectedReposChanged) {
        throw new HelpfulError(
          'Cannot update secret visibility without re-providing the secret value. ' +
          'GitHub API requires the encrypted value for any secret update.',
          {
            desiredSecret: desired,
            currentVisibility: before.visibility,
            desiredVisibility: desired.visibility,
          },
        );
      }

      // No changes needed, return existing metadata
      return before;
    }

    // Get org's public key for encryption
    const keyResponse = await github.actions.getOrgPublicKey({ org: desired.org.login });

    // Encrypt the secret value
    const encryptedValue = await encryptSecret({ value: desired.value!, publicKey: keyResponse.data.key });

    // Resolve repo IDs if visibility is 'selected'
    const selectedRepositoryIds = desired.visibility === 'selected' && desired.selectedRepositoryNames
      ? await getRepoIdsByNames({ org: desired.org.login, names: desired.selectedRepositoryNames }, context)
      : undefined;

    // Create or update secret
    try {
      await github.actions.createOrUpdateOrgSecret({
        org: desired.org.login,
        secret_name: desired.name,
        encrypted_value: encryptedValue,
        key_id: keyResponse.data.key_id,
        visibility: desired.visibility,
        selected_repository_ids: selectedRepositoryIds,
      });

      return (await getOneOrgSecret(
        { by: { unique: { org: desired.org, name: desired.name } } },
        context,
      ))!;
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      throw new HelpfulError('github.setOrgSecret error', { cause: error });
    }
  },
);
```

#### delOrgSecret

```typescript
import { asProcedure } from 'as-procedure';
import { HelpfulError } from 'helpful-errors';
import type { VisualogicContext } from 'visualogic';

import { getGithubClient } from '../../access/sdks/getGithubClient';
import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import type { DeclaredGithubOrgSecret } from '../../domain.objects/DeclaredGithubOrgSecret';

/**
 * .what = deletes a GitHub Organization secret
 * .why = enables declarative management of org-level secrets
 */
export const delOrgSecret = asProcedure(
  async (
    input: { secret: DeclaredGithubOrgSecret },
    context: ContextGithubApi & VisualogicContext,
  ): Promise<void> => {
    const github = getGithubClient({}, context);

    try {
      await github.actions.delOrgSecret({
        org: input.secret.org.login,
        secret_name: input.secret.name,
      });
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      throw new HelpfulError('github.delOrgSecret error', { cause: error });
    }
  },
);
```

---

## Access DAOs

### DeclaredGithubOrgDao

```typescript
import { DeclastructDao } from 'declastruct';
import { isRefByUnique } from 'domain-objects';
import { UnexpectedCodePathError } from 'helpful-errors';
import type { ContextLogTrail } from 'simple-log-methods';

import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import { DeclaredGithubOrg } from '../../domain.objects/DeclaredGithubOrg';
import { getOneOrg } from '../../domain.operations/org/getOneOrg';
import { setOrg } from '../../domain.operations/org/setOrg';

/**
 * .what = declastruct DAO for GitHub Organization resources
 * .why = wraps org operations to conform to declastruct interface
 * .note = orgs cannot be created via API; only existing orgs can be updated
 */
export const DeclaredGithubOrgDao = new DeclastructDao<
  typeof DeclaredGithubOrg,
  ContextGithubApi & ContextLogTrail
>({
  dobj: DeclaredGithubOrg,
  get: {
    one: {
      byUnique: async (input, context) => {
        return getOneOrg({ by: { unique: input } }, context);
      },
      byPrimary: undefined,
      byRef: async (input, context) => {
        if (isRefByUnique({ of: DeclaredGithubOrg })(input))
          return getOneOrg({ by: { unique: input } }, context);
        UnexpectedCodePathError.throw('unsupported ref type', { input });
      },
    },
    ref: {
      byPrimary: undefined,
      byUnique: undefined,
    },
  },
  set: {
    findsert: async (input, context) => {
      return setOrg({ findsert: input }, context);
    },
    upsert: async (input, context) => {
      return setOrg({ upsert: input }, context);
    },
    delete: undefined, // Cannot delete orgs via this interface
  },
});
```

### DeclaredGithubOrgMemberPrivilegesDao

```typescript
import { DeclastructDao } from 'declastruct';
import { isRefByUnique } from 'domain-objects';
import { UnexpectedCodePathError } from 'helpful-errors';
import type { ContextLogTrail } from 'simple-log-methods';

import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import { DeclaredGithubOrgMemberPrivileges } from '../../domain.objects/DeclaredGithubOrgMemberPrivileges';
import { getOneOrgMemberPrivileges } from '../../domain.operations/orgMemberPrivileges/getOneOrgMemberPrivileges';
import { setOrgMemberPrivileges } from '../../domain.operations/orgMemberPrivileges/setOrgMemberPrivileges';

/**
 * .what = declastruct DAO for GitHub Organization Member Privileges
 * .why = wraps member privilege operations to conform to declastruct interface
 * .note = KEY SECURITY RESOURCE - controls what non-owners can do
 */
export const DeclaredGithubOrgMemberPrivilegesDao = new DeclastructDao<
  typeof DeclaredGithubOrgMemberPrivileges,
  ContextGithubApi & ContextLogTrail
>({
  dobj: DeclaredGithubOrgMemberPrivileges,
  get: {
    one: {
      byUnique: async (input, context) => {
        return getOneOrgMemberPrivileges({ by: { unique: input } }, context);
      },
      byPrimary: undefined,
      byRef: async (input, context) => {
        if (isRefByUnique({ of: DeclaredGithubOrgMemberPrivileges })(input))
          return getOneOrgMemberPrivileges({ by: { unique: input } }, context);
        UnexpectedCodePathError.throw('unsupported ref type', { input });
      },
    },
    ref: {
      byPrimary: undefined,
      byUnique: undefined,
    },
  },
  set: {
    findsert: async (input, context) => {
      return setOrgMemberPrivileges({ findsert: input }, context);
    },
    upsert: async (input, context) => {
      return setOrgMemberPrivileges({ upsert: input }, context);
    },
    delete: undefined, // Cannot delete member privileges (they always exist for an org)
  },
});
```

### DeclaredGithubOrgVariableDao

```typescript
import { DeclastructDao } from 'declastruct';
import { isRefByUnique } from 'domain-objects';
import { UnexpectedCodePathError } from 'helpful-errors';
import type { ContextLogTrail } from 'simple-log-methods';

import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import { DeclaredGithubOrgVariable } from '../../domain.objects/DeclaredGithubOrgVariable';
import { getOneOrgVariable } from '../../domain.operations/orgVariable/getOneOrgVariable';
import { setOrgVariable } from '../../domain.operations/orgVariable/setOrgVariable';
import { delOrgVariable } from '../../domain.operations/orgVariable/delOrgVariable';

/**
 * .what = declastruct DAO for GitHub Organization Variable resources
 * .why = wraps variable operations to conform to declastruct interface
 */
export const DeclaredGithubOrgVariableDao = new DeclastructDao<
  typeof DeclaredGithubOrgVariable,
  ContextGithubApi & ContextLogTrail
>({
  dobj: DeclaredGithubOrgVariable,
  get: {
    one: {
      byUnique: async (input, context) => {
        return getOneOrgVariable({ by: { unique: input } }, context);
      },
      byPrimary: undefined,
      byRef: async (input, context) => {
        if (isRefByUnique({ of: DeclaredGithubOrgVariable })(input))
          return getOneOrgVariable({ by: { unique: input } }, context);
        UnexpectedCodePathError.throw('unsupported ref type', { input });
      },
    },
    ref: {
      byPrimary: undefined,
      byUnique: undefined,
    },
  },
  set: {
    findsert: async (input, context) => {
      return setOrgVariable({ findsert: input }, context);
    },
    upsert: async (input, context) => {
      return setOrgVariable({ upsert: input }, context);
    },
    delete: async (input, context) => {
      return delOrgVariable({ variable: input }, context);
    },
  },
});
```

### DeclaredGithubOrgSecretDao

```typescript
import { DeclastructDao } from 'declastruct';
import { isRefByUnique } from 'domain-objects';
import { UnexpectedCodePathError } from 'helpful-errors';
import type { ContextLogTrail } from 'simple-log-methods';

import type { ContextGithubApi } from '../../domain.objects/ContextGithubApi';
import { DeclaredGithubOrgSecret } from '../../domain.objects/DeclaredGithubOrgSecret';
import { getOneOrgSecret } from '../../domain.operations/orgSecret/getOneOrgSecret';
import { setOrgSecret } from '../../domain.operations/orgSecret/setOrgSecret';
import { delOrgSecret } from '../../domain.operations/orgSecret/delOrgSecret';

/**
 * .what = declastruct DAO for GitHub Organization Secret resources
 * .why = wraps secret operations to conform to declastruct interface
 * .note = secrets are write-only; values are never readable
 */
export const DeclaredGithubOrgSecretDao = new DeclastructDao<
  typeof DeclaredGithubOrgSecret,
  ContextGithubApi & ContextLogTrail
>({
  dobj: DeclaredGithubOrgSecret,
  get: {
    one: {
      byUnique: async (input, context) => {
        return getOneOrgSecret({ by: { unique: input } }, context);
      },
      byPrimary: undefined,
      byRef: async (input, context) => {
        if (isRefByUnique({ of: DeclaredGithubOrgSecret })(input))
          return getOneOrgSecret({ by: { unique: input } }, context);
        UnexpectedCodePathError.throw('unsupported ref type', { input });
      },
    },
    ref: {
      byPrimary: undefined,
      byUnique: undefined,
    },
  },
  set: {
    findsert: async (input, context) => {
      return setOrgSecret({ findsert: input }, context);
    },
    upsert: async (input, context) => {
      return setOrgSecret({ upsert: input }, context);
    },
    delete: async (input, context) => {
      return delOrgSecret({ secret: input }, context);
    },
  },
});
```

---

## Provider Updates

### Updated DeclastructGithubProvider

```typescript
import type { DeclastructDao, DeclastructProvider } from 'declastruct';
import type { ContextLogTrail } from 'simple-log-methods';

import type { ContextGithubApi } from './ContextGithubApi';
import type { DeclaredGithubApp } from './DeclaredGithubApp';
import type { DeclaredGithubAppInstallation } from './DeclaredGithubAppInstallation';
import type { DeclaredGithubBranch } from './DeclaredGithubBranch';
import type { DeclaredGithubBranchProtection } from './DeclaredGithubBranchProtection';
import type { DeclaredGithubOrg } from './DeclaredGithubOrg';
import type { DeclaredGithubOrgMemberPrivileges } from './DeclaredGithubOrgMemberPrivileges';
import type { DeclaredGithubOrgVariable } from './DeclaredGithubOrgVariable';
import type { DeclaredGithubOrgSecret } from './DeclaredGithubOrgSecret';
import type { DeclaredGithubRepo } from './DeclaredGithubRepo';
import type { DeclaredGithubRepoConfig } from './DeclaredGithubRepoConfig';

/**
 * .what = the declastruct provider for github resources
 * .why = provides type safety and reusability for the github provider
 */
export type DeclastructGithubProvider = DeclastructProvider<
  {
    // Existing resources
    DeclaredGithubRepo: DeclastructDao<typeof DeclaredGithubRepo, ContextGithubApi & ContextLogTrail>;
    DeclaredGithubBranch: DeclastructDao<typeof DeclaredGithubBranch, ContextGithubApi & ContextLogTrail>;
    DeclaredGithubRepoConfig: DeclastructDao<typeof DeclaredGithubRepoConfig, ContextGithubApi & ContextLogTrail>;
    DeclaredGithubBranchProtection: DeclastructDao<typeof DeclaredGithubBranchProtection, ContextGithubApi & ContextLogTrail>;
    DeclaredGithubApp: DeclastructDao<typeof DeclaredGithubApp, ContextGithubApi & ContextLogTrail>;
    DeclaredGithubAppInstallation: DeclastructDao<typeof DeclaredGithubAppInstallation, ContextGithubApi & ContextLogTrail>;

    // NEW: Organization resources
    DeclaredGithubOrg: DeclastructDao<typeof DeclaredGithubOrg, ContextGithubApi & ContextLogTrail>;
    DeclaredGithubOrgMemberPrivileges: DeclastructDao<typeof DeclaredGithubOrgMemberPrivileges, ContextGithubApi & ContextLogTrail>;
    DeclaredGithubOrgVariable: DeclastructDao<typeof DeclaredGithubOrgVariable, ContextGithubApi & ContextLogTrail>;
    DeclaredGithubOrgSecret: DeclastructDao<typeof DeclaredGithubOrgSecret, ContextGithubApi & ContextLogTrail>;
  },
  ContextGithubApi & ContextLogTrail
>;
```

---

## Summary

### New Files Required

**Domain Objects:**
- `src/domain.objects/DeclaredGithubOrg.ts`
- `src/domain.objects/DeclaredGithubOrgMemberPrivileges.ts`
- `src/domain.objects/DeclaredGithubOrgVariable.ts`
- `src/domain.objects/DeclaredGithubOrgSecret.ts`

**Domain Operations:**
- `src/domain.operations/org/getOneOrg.ts`
- `src/domain.operations/org/setOrg.ts`
- `src/domain.operations/org/castToDeclaredGithubOrg.ts`
- `src/domain.operations/orgMemberPrivileges/getOneOrgMemberPrivileges.ts`
- `src/domain.operations/orgMemberPrivileges/setOrgMemberPrivileges.ts`
- `src/domain.operations/orgMemberPrivileges/castToDeclaredGithubOrgMemberPrivileges.ts`
- `src/domain.operations/orgVariable/getOneOrgVariable.ts`
- `src/domain.operations/orgVariable/getAllOrgVariables.ts`
- `src/domain.operations/orgVariable/setOrgVariable.ts`
- `src/domain.operations/orgVariable/delOrgVariable.ts`
- `src/domain.operations/orgVariable/castToDeclaredGithubOrgVariable.ts`
- `src/domain.operations/orgSecret/getOneOrgSecret.ts`
- `src/domain.operations/orgSecret/getAllOrgSecrets.ts`
- `src/domain.operations/orgSecret/setOrgSecret.ts`
- `src/domain.operations/orgSecret/delOrgSecret.ts`
- `src/domain.operations/orgSecret/castToDeclaredGithubOrgSecret.ts`
- `src/domain.operations/repo/getRepoIdsByNames.ts` (helper)

**Access:**
- `src/access/daos/DeclaredGithubOrgDao.ts`
- `src/access/daos/DeclaredGithubOrgMemberPrivilegesDao.ts`
- `src/access/daos/DeclaredGithubOrgVariableDao.ts`
- `src/access/daos/DeclaredGithubOrgSecretDao.ts`

**Updates:**
- `src/domain.objects/DeclastructGithubProvider.ts` - add new DAOs
- `src/domain.operations/provider/getDeclastructGithubProvider.ts` - wire up new DAOs
- `src/contract/sdks/index.ts` - export new types

**Dependencies:**
- `libsodium-wrappers` - for encrypting secrets

### Key Implementation Notes

1. **Authentication:** Requires `admin:org` scope on the GitHub token for all org-level operations.

2. **Security Settings:** The key wish fulfillment is setting:
   - `membersCanDeleteRepositories: false`
   - `membersCanChangeRepoVisibility: false`

3. **Write-Only Secrets:** Secrets use a special pattern where:
   - Reading returns metadata only (no value)
   - Writing requires encryption with libsodium
   - If value is undefined on upsert, existing secret is kept

4. **Visibility Scoping:** Both variables and secrets support three visibility levels:
   - `all` - all repos in org
   - `private` - only private repos
   - `selected` - specific repos (requires resolving repo IDs)

---

## Automation vs Manual Action Summary

### What We FULLY AUTOMATE (via REST API)

| Operation           | API Endpoint                                                 |
| ------------------- | ------------------------------------------------------------ |
| Read org settings   | `GET /orgs/{org}`                                            |
| Update org settings | `PATCH /orgs/{org}`                                          |
| List variables      | `GET /orgs/{org}/actions/variables`                          |
| CRUD variables      | `POST/GET/PATCH/DELETE /orgs/{org}/actions/variables/{name}` |
| List secrets        | `GET /orgs/{org}/actions/secrets`                            |
| CRUD secrets        | `PUT/GET/DELETE /orgs/{org}/actions/secrets/{name}`          |
| Get public key      | `GET /orgs/{org}/actions/secrets/public-key`                 |

### What Cannot Be Automated

| Operation          | Why                    | User Action           |
| ------------------ | ---------------------- | --------------------- |
| Create org         | No API exists          | Create via GitHub UI  |
| Delete org         | Dangerous; requires UI | Delete via GitHub UI  |
| Read secret values | Write-only by design   | Values never readable |
